{"version":3,"sources":["worker/bodyPix.js","serviceWorker.js","context/webcam.js","components/Webcam.js","components/FileUpload.js","components/GameSelect.js","components/SelectAndCheck.js","components/WebcamSelect.js","components/ScoreResults.js","components/CapturedMasks.js","hooks/speech.js","hooks/lapTimer.js","hooks/bodyPixController.js","context/bodyPix.js","hooks/loop.js","hooks/loopTime.js","lib/util.js","hooks/loopHandlers/simpleGame.js","hooks/iterateMask.js","hooks/loopHandlers/captureMasks.js","components/Main.js","hooks/singleCapture.js","App/App.js","index.js"],"names":["addMethods","methods","module","exports","w","Worker","name","Boolean","window","location","hostname","match","webcamContext","createContext","useWebcam","state","useContext","Error","hasVideo","navigator","mediaDevices","getUserMedia","WebcamProvider","children","videoRef","useRef","canvasRef","useState","ctx","setCtx","flipX","setFlipX","ready","setReady","cameras","setCameras","scratchpad","setScratchpad","videoError","setVideoError","videoStream","setVideoStream","currentDeviceId","setCurrentDeviceId","autoStartDeviceId","_setAutoStartDeviceId","useEffect","current","getContext","canvas","document","createElement","width","height","_ctx","clearScratchpad","useCallback","clearRect","clearCanvas","stopVideo","getTracks","forEach","track","stop","startVideo","userConstraintsOrDeviceIdx","a","console","error","userConstraints","isDeviceIdx","deviceIdx","log","constraints","video","exact","audio","undefined","deviceId","stream","getCapabilities","srcObject","message","Promise","all","resolve","onloadedmetadata","onloadeddata","then","discoverCameras","enumerateDevices","devices","foundCameras","filter","kind","label","includes","map","currentCamera","idx","lastIndexOf","slice","toggleFlipX","setAutoStartDeviceId","localStorage","setItem","clearAutoStartDeviceId","removeItem","imageDataToDataUri","imageData","putImageData","dataUri","toDataURL","dataUriToImageData","img","Image","src","onload","drawImage","getImageData","getVideoAsImageData","autoStartId","getItem","length","context","useMemo","start","Provider","value","useStyles","makeStyles","theme","root","props","position","transform","top","left","Webcam","webcam","classes","className","autoPlay","ref","videoWidth","videoHeight","fileInput","display","FileUpload","onChange","multiple","buttonProps","fileRef","handleFileUpload","fileObject","disallowMultiple","allFiles","target","Array","from","files","filteredFiles","resetFile","Button","component","type","onClick","formControl","minWidth","select","paddingTop","spacing","paddingBottom","GameSelect","FormControl","Select","placeholder","displayEmpty","variant","MenuItem","_","key","noop","arrowIcon","marginLeft","tooltip","margin","arrow","fontSize","content","borderStyle","paper","border","popper","marginTop","borderWidth","borderColor","palette","grey","bottom","marginBottom","right","marginRight","SelectAndCheck","id","Math","random","anchorEl","setAnchorEl","arrowRef","setArrowRef","handleClickSelect","event","currentTarget","closeSelect","handleCloseSelect","onClose","handleClickCheckbox","onClickCheckbox","handleClickSelectItem","onSelect","open","disableRipple","aria-haspopup","button","aria-controls","SelectProps","activeTitle","title","Menu","keepMounted","elevation","getContentAnchorEl","anchorOrigin","vertical","horizontal","transformOrigin","MenuProps","options","i","text","selected","tooltipTitle","checked","checkboxValue","TooltipAndCheckbox","_Checkbox","Checkbox","tooltipText","Tooltip","PopperProps","popperOptions","modifiers","enabled","element","Fragment","enterDelay","tooltipEnterDelay","leaveDelay","tooltipLeaveDelay","aria-label","placement","tooltipPlacement","MenuItemProps","ListItemText","primary","toString","WebcamSelect","selectedCamera","_selectedCamera","none","some","camera","handleSelectCamera","handleSetDefaultCamera","masks","padding","masksHeader","masksList","flexFlow","justifyContent","imgContainer","textAlign","background","ScoreResults","results","Paper","Typography","reduce","acc","score","alt","alignItems","removeMask","transition","iconBtn","color","backgroundColor","CapturedMasks","captureMasks","downloadMasks","removeAllMasks","binary","IconButton","synth","speechSynthesis","useLapTimer","lapTimer","speech","voices","setVoices","voice","setVoice","allVoices","getVoices","say","utterance","SpeechSynthesisUtterance","speak","countdown","onEnd","onEach","setTimeout","num","useSpeech","useTimer","onBeforeStartLap","onLap","maxLaps","lapDuration","postLapDelay","printSeconds","announceSeconds","onBeforeComplete","onBeforeStarted","numLaps","handleLap","time","predict","resetLapTime","secondsPassed","floor","lapTime","max","font","fillStyle","fillText","lastSpeech","handlerCalled","handlerResolved","lapNum","clear","bodyPixWorker","BodyPixWorker","bodyPixContext","useBodyPix","BodyPixProvider","loadRef","preloadRef","netReady","setNetReady","netPreloaded","setNetPreloaded","load","catch","segmentation","useBodyPixController","useLoop","handleLoop","loopTime","lastTimeRef","startTimeRef","totalFramesRef","fpsSumRef","reset","timestamp","update","first","deltaTime","fps","avgFps","elapsed","frames","useLoopTime","loopingRef","handleLoopRef","looping","setLooping","setStartLoop","setStopLoop","loop","cleanup","requestAnimationFrame","getSegmentationeOverlayAndBinaryImageData","flipped","data","binaryBytes","Uint8ClampedArray","x","y","parseInt","isPerson","bytes_index","binaryImageData","ImageData","segData","cv","matFromImageData","rgbaPlanes","MatVector","split","pre_mask","Mat","threshold","get","THRESH_BINARY","contours","hierarchy","findContours","RETR_CCOMP","CHAIN_APPROX_SIMPLE","mask","zeros","rows","cols","CV_8UC1","size","contourArea","drawContours","LINE_8","overlay","CV_8UC4","setTo","borderMask","M","ones","CV_8U","anchor","Point","dilate","BORDER_CONSTANT","morphologyDefaultBorderValue","subtract","merge","overlayImageData","delete","getScoreAndOverlayForSegmentationAndImageData","targetImageData","bytes","union","intersection","isInPolygon","isIntersection","isMissedPolygon","isPersonOutOfPolygon","isInteresting","round","useSimpleGame","promRef","loading","setLoading","maskIterator","setMasks","maskRef","maskIdxRef","next","currentPoly","numMasks","useIterateMask","scores","setScores","selectedMasks","setSelectedMasks","handleZip","file","JSZip","loadAsync","endsWith","async","binaryMasks","b64","masksAsImageData","handleLoadUserMasks","handleLoadShippedMasks","filename","external","reject","JSZipUtils","getBinaryContent","process","err","controller","newLapDelay","useCaptureMasks","index","zip","folder","imageDataUri","decode","dataBase64","base64","generateAsync","zipFile","blob","msSaveOrOpenBlob","msSaveBlob","elem","href","URL","createObjectURL","download","style","body","documentElement","appendChild","click","dispatchEvent","MouseEvent","view","bubbles","cancelable","revokeObjectURL","saveAs","overlayDataUri","binaryDataUri","maxWidth","flexDirection","clickStates","Main","simpleGame","handleSingleCapture","useSingleCapture","lastClick","setLastClick","handleClickGame","handleClickCapture","disabled","createMuiTheme","cvReady","setCvReady","interval","setInterval","clearInterval","CssBaseline","ReactDOM","render","getElementById","serviceWorker","registration","unregister"],"mappings":"iIACI,IAAIA,EAAa,EAAQ,KACrBC,EAAU,CAAC,OAAO,WACtBC,EAAOC,QAAU,WAChB,IAAIC,EAAI,IAAIC,OAAO,IAA0B,iCAAkC,CAAEC,KAAM,qBAGvF,OAFAN,EAAWI,EAAGH,GAEPG,I,ycCKQG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,6GChBOC,EAAgBC,0BAEhBC,EAAY,WACvB,IAAMC,EAAQC,qBAAWJ,GAEzB,IAAKG,EACH,MAAM,IAAIE,MAAM,kDAGlB,OAAOF,GAMHG,KAAY,UAAEC,iBAAF,iBAAE,EAAWC,oBAAb,aAAE,EAAyBC,cAoQ9BC,EAlQQ,SAAC,GAAgB,IAAfC,EAAc,EAAdA,SACjBC,EAAWC,mBACXC,EAAYD,mBAFmB,EAGfE,mBAAS,MAHM,mBAG9BC,EAH8B,KAGzBC,EAHyB,OAIXF,oBAAS,GAJE,mBAI9BG,EAJ8B,KAIvBC,EAJuB,OAKXJ,oBAAS,GALE,mBAK9BK,EAL8B,KAKvBC,EALuB,OAMPN,mBAAS,IANF,mBAM9BO,EAN8B,KAMrBC,EANqB,OAODR,mBAAS,MAPR,mBAO9BS,EAP8B,KAOlBC,EAPkB,OAQDV,mBAAS,MARR,mBAQ9BW,EAR8B,KAQlBC,EARkB,OASCZ,mBAAS,MATV,mBAS9Ba,EAT8B,KASjBC,EATiB,OAUSd,mBAAS,MAVlB,mBAU9Be,EAV8B,KAUbC,EAVa,OAWchB,mBAAS,MAXvB,mBAW9BiB,EAX8B,KAWXC,EAXW,KAarCC,qBAAU,WACJpB,EAAUqB,UAAYnB,EACxBC,EAAOH,EAAUqB,QAAQC,WAAW,OAC3BpB,IAAQF,EAAUqB,SAC3BlB,EAAO,QAER,CAACD,IAIJkB,qBAAU,WACR,GAAId,IAAUI,EAAY,CACxB,IAAMa,EAASC,SAASC,cAAc,UACtCF,EAAOG,MAAQ1B,EAAUqB,QAAQK,MACjCH,EAAOI,OAAS3B,EAAUqB,QAAQM,OAClC,IAAMC,EAAOL,EAAOD,WAAW,MAE/BX,EAAc,CAAET,IAAK0B,EAAML,cAE5B,CAACb,EAAYJ,IAEhB,IAAMuB,EAAkBC,uBAAY,WAClCpB,EAAWR,IAAI6B,UAAU,EAAG,EAAG/B,EAAUqB,QAAQK,MAAO1B,EAAUqB,QAAQM,UACzE,CAACjB,IAEEsB,EAAcF,uBAAY,WAC9B5B,EAAI6B,UAAU,EAAG,EAAG/B,EAAUqB,QAAQK,MAAO1B,EAAUqB,QAAQM,UAC9D,CAACzB,IAEE+B,EAAYH,uBAAY,WACxBhB,GACFA,EAAYoB,YAAYC,SAAQ,SAAAC,GAAK,OAAIA,EAAMC,UAGjDxB,EAAc,MACdE,EAAe,MACfR,GAAS,GACTU,EAAmB,QAClB,CAACH,IAEEwB,EAAaR,sBAAW,uCAAC,WAAOS,GAAP,+BAAAC,EAAA,yDAC7BP,IAEKzC,EAHwB,sBAIX,sBAEhBiD,QAAQC,MAFQ,uBAGhB7B,EAHgB,uBAJW,iCAcvB8B,GAFAC,EAAqD,kBAA/BL,GAEW,GAAKA,GAA8B,GACpEM,EAAaD,EAAcL,EAA6BI,EAAgBE,UAfjD,SAkB3BJ,QAAQK,IAAI,qBACNC,EAAc,CAClBC,MAAO,CACLtB,MAAO,CAAEuB,MAAON,EAAgBjB,OA/EtB,MAgFVC,OAAQ,CAAEsB,MAAON,EAAgBhB,QA/EtB,MAiFbuB,OAAO,QAGSC,IAAdN,IACFF,EAAgBS,SAAhB,UAA2B5C,EAAQqC,UAAnC,aAA2B,EAAoBO,UAG7CT,EAAgBS,WAClBL,EAAYC,MAAMI,SAAW,CAAEH,MAAON,EAAgBS,WAhC7B,UAmCN3D,UAAUC,aAAaC,aAAaoD,GAnC9B,QAmCrBM,EAnCqB,OAoCrBD,EApCqB,UAoCVC,EAAOnB,YAAY,UApCT,iBAoCV,EAAuBoB,yBApCb,aAoCV,EAA0CF,SAE3DX,QAAQK,IAAI,eACZ/B,EAAesC,GACfpC,EAAmBmC,GACnBtD,EAASuB,QAAQkC,UAAYF,EAzCF,yDA2CX,wBAChBZ,QAAQC,MADQ,yBAEhBD,QAAQC,MAAM,KAAEc,SAChBzC,EAAe,MACfR,GAAS,GACTM,EALgB,yBA3CW,4CAqDhB4C,QAAQC,IAAI,CACvB,IAAID,SAAQ,SAAAE,GACV7D,EAASuB,QAAQuC,iBAAmB,kBAAMD,QAE5C,IAAIF,SAAQ,SAAAE,GACV7D,EAASuB,QAAQwC,aAAe,kBAAMF,UAEvCG,MAAK,kBAAMvD,GAAS,MA5DM,mGAAD,sDA6D3B,CAAC0B,EAAWnC,EAAUU,IAEnBuD,EAAkBjC,sBAAW,sBAAC,kCAAAU,EAAA,mEACT/C,iBADS,iBACT,EAAWC,oBADF,aACT,EAAyBsE,iBADhB,uBAIhCvB,QAAQC,MAAM,uBAJkB,kBAMzB,IANyB,uBASZjD,UAAUC,aAAasE,mBATX,cAS5BC,EAT4B,OAU5BC,EAAeD,EAAQE,QAAO,gBAAGC,EAAH,EAAGA,KAAMC,EAAT,EAASA,MAAT,MACxB,eAATD,IAA2BC,EAAMC,SAAS,eAE1CC,KAAI,SAAAC,GACH,IAAIH,EACEI,EAAMD,EAAcH,MAAMK,YAAY,MAG5C,OAFID,GAAO,IAAGJ,EAAQG,EAAcH,MAAMM,MAAM,EAAGF,IAE3CJ,EAAS,CAAEjB,SAAUoB,EAAcpB,SAAUiB,SAAWG,KAGpE/D,EAAWyD,GArBuB,kBAuB3BA,GAvB2B,4CAwBjC,IAEGU,EAAc9C,uBAAY,kBAAMzB,GAAS,SAAAhB,GAAK,OAAKA,OAAQ,IAE3DwF,EAAuB/C,uBAAY,SAACsB,GACxCtE,OAAOgG,aAAaC,QApJF,cAoJyB3B,GAC3CjC,EAAsBiC,KACrB,IAEG4B,GAAyBlD,uBAAY,WACzChD,OAAOgG,aAAaG,WAzJF,eA0JlB9D,EAAsB,QACrB,IAEG+D,GAAqBpD,uBAAY,SAACqD,GACtCtD,IACAnB,EAAWR,IAAIkF,aAAaD,EAAW,EAAG,GAC1C,IAAME,EAAU3E,EAAWa,OAAO+D,UAAU,aAG5C,OAFAzD,IAEOwD,IACN,CAAC3E,EAAYmB,IAEV0D,GAAqBzD,sBAAW,uCAAC,WAAOuD,GAAP,iBAAA7C,EAAA,6DACrCX,KACM2D,EAAM,IAAIC,OACZC,IAAML,EAH2B,SAK/B,IAAI5B,SAAQ,SAACE,GACjB6B,EAAIG,OAAS,WACXjF,EAAWR,IAAI0F,UAAUJ,EAAK,EAAG,GACjC7B,QARiC,cAY/BwB,EAAYzE,EAAWR,IAAI2F,aAAa,EAAG,EAAG7F,EAAUqB,QAAQK,MAAO1B,EAAUqB,QAAQM,QAC/FE,IAbqC,kBAe9BsD,GAf8B,2CAAD,sDAgBnC,CAACtD,EAAiBnB,IAEfoF,GAAsBhE,uBAAY,WACtCD,IACAnB,EAAWR,IAAI0F,UAAU9F,EAASuB,QAAS,EAAG,GAC9C,IAAM8D,EAAYzE,EAAWR,IAAI2F,aAAa,EAAG,EAAG7F,EAAUqB,QAAQK,MAAO1B,EAAUqB,QAAQM,QAG/F,OAFAE,IAEOsD,IACN,CAACtD,EAAiBnB,IAErBU,qBAAU,WACR2C,IACGD,MAAK,SAACI,GAEL,IAAM6B,EAAcjH,OAAOgG,aAAakB,QArM1B,eAsMd7E,EAAsB4E,KACC7B,EAAaC,QAAO,qBAAGf,WAA4B2C,KAAaE,QAEtE3D,EAAW,CAAEc,SAAU2C,SAE3C,IAEH,IAAMG,GAAUC,mBAAQ,iBAAO,CAC7BjG,MACAI,QACAF,QACAI,UACAH,WACAP,WACAN,WACAQ,YACAiC,YACAK,aACA1B,aACAF,aACAsB,cACA4C,cACA9D,cACAE,kBACAqB,KAAMJ,EACN8B,kBACA7C,oBACAkF,MAAO9D,EACP4C,sBACAK,sBACAO,uBACAjB,uBACAG,6BACE,CACF9E,EACAI,EACAF,EACAI,EACAH,EACA4B,EACAK,EACA1B,EACAF,EACAkE,EACA5C,EACAlB,EACAE,EACA+C,EACA7C,EACAgE,GACAK,GACAO,GACAjB,EACAG,KAGF,OACE,kBAAC9F,EAAcmH,SAAf,CAAwBC,MAAOJ,IAC5BrG,IC1QD0G,EAAYC,aAAW,SAACC,GAAD,MAAY,CACvCC,KAAM,SAACC,GAAD,MAAY,CAChBC,SAAU,aAEZ5D,MAAO,SAAC2D,GAAD,oBACLjF,MAAO,OACPC,OAAQ,QACJgF,EAAMvG,MAAQ,CAChB,qBAAsB,cACtByG,UAAW,cACT,KAENtF,OAAQ,SAACoF,GAAD,MAAY,CAClBC,SAAU,WACVE,IAAK,EACLC,KAAM,EACNrF,MAAO,aA+BIsF,EA3BA,SAACL,GAAW,IAAD,gBAClBM,EAAS7H,IACT8H,EAAUX,EAAU,2BAAKI,GAAUM,IAEzC,OACE,yBAAKE,UAAWD,EAAQR,MACtB,2BACEU,UAAU,EACVC,IAAKJ,EAAOnH,SACZqH,UAAWD,EAAQlE,MACnBtB,MAAK,UAAEuF,EAAOnH,gBAAT,iBAAE,EAAiBuB,eAAnB,aAAE,EAA0BiG,WACjC3F,OAAM,UAAEsF,EAAOnH,gBAAT,iBAAE,EAAiBuB,eAAnB,aAAE,EAA0BkG,cAEpC,4BACEF,IAAKJ,EAAOjH,UACZmH,UAAWD,EAAQ3F,OACnBG,MAAK,UAAEuF,EAAOnH,gBAAT,iBAAE,EAAiBuB,eAAnB,aAAE,EAA0BiG,WACjC3F,OAAM,UAAEsF,EAAOnH,gBAAT,iBAAE,EAAiBuB,eAAnB,aAAE,EAA0BkG,gB,SCrCpChB,EAAYC,aAAW,SAACC,GAAD,MAAY,CACvCe,UAAW,CACTC,QAAS,YAuDEC,EAnDI,SAAC,GAMb,IALLC,EAKI,EALJA,SACAC,EAII,EAJJA,SACA/H,EAGI,EAHJA,SACAsE,EAEI,EAFJA,OACG0D,EACC,2DACEX,EAAUX,IAEVuB,EAAU/H,mBAEVgI,EAAmBjG,uBAAY,SAACkG,GACpC,GAAKA,EAAL,CAEA,IAAMC,GAAiC,IAAbL,EACpBM,EAAYF,EAAWG,OAASC,MAAMC,KAAKL,EAAWG,OAAOG,OAASN,EAAWM,MACnFC,EAAiBpE,EAAS+D,EAAS/D,OAAOA,GAAU+D,EAEpDD,GAAoBM,EAActC,OAAS,IAC7CsC,EAAgBA,EAAc5D,MAAM,EAAG,IAGzCgD,EAASY,MACR,CAACZ,EAAUC,EAAUzD,IAElBqE,EAAY1G,uBAAY,WAC5BgG,EAAQzG,QAAQiF,MAAQ,OACvB,CAACwB,IAEJ,OACE,kBAACW,EAAA,EAAD,eAAQC,UAAU,SAAYb,GAC3BhI,EACD,2BACE8I,KAAK,OACLtB,IAAKS,EACLX,UAAWD,EAAQM,UACnBoB,QAASJ,EACTb,SAAUI,EACVH,UAAwB,IAAbA,M,2BCzCbrB,EAAYC,aAAW,SAAAC,GAAK,MAAK,CACrCoC,YAAa,CACXC,SAAU,KAEZC,OAAQ,CACNC,WAAYvC,EAAMwC,QAAQ,GAC1BC,cAAezC,EAAMwC,QAAQ,QAyBlBE,EArBI,SAAC,GAAyB,IAAvB7C,EAAsB,EAAtBA,MAAUK,EAAY,yBACpCO,EAAUX,IAEhB,OACE,kBAAC6C,EAAA,EAAD,CAAajC,UAAWD,EAAQ2B,aAC9B,kBAACQ,EAAA,EAAD,eAAQnC,QAAS,CAAER,KAAMQ,EAAQ6B,SAAcpC,EAA/C,CAAsD2C,YAAY,cAAchD,MAAOA,GAAS,GAAIiD,cAAc,EAAMC,QAAQ,aAC9H,kBAACC,EAAA,EAAD,CAAUnD,MAAM,IAAhB,gBACC8B,MAAMC,KAAK,CAAEpC,OAAQ,IAAK1B,KAAI,SAACmF,EAAGjF,GAAJ,OAC7B,kBAACgF,EAAA,EAAD,CAAUE,IAAKlF,EAAK6B,MAAK,aAAQ7B,EAAM,EAAd,SAAzB,QAAsDA,EAAM,S,wECdhEmF,EAAO,aAEPrD,EAAYC,aAAW,SAACC,GAAD,MAAY,CACvCC,KAAM,SAACC,GAAD,MAAY,CAChBC,SAAU,aAEZiD,UAAW,SAAClD,GAAD,MAAY,CACrBmD,WAAYrD,EAAMwC,QAAQ,KAE5Bc,QAAS,SAACpD,GAAD,MAAY,CACnBC,SAAU,WACVoD,OAAQ,IAEVC,MAAO,SAACtD,GAAD,MAAY,CACjBC,SAAU,WACVsD,SAAU,EACV,YAAa,CACXC,QAAS,KACTH,OAAQ,OACRvC,QAAS,QACT/F,MAAO,EACPC,OAAQ,EACRyI,YAAa,WAGjBC,MAAO,CACLC,OAAQ,qBAEVC,OAAQ,SAAC5D,GAAD,MAAY,CAClB,kCAAmC,CACjCG,IAAK,EACLC,KAAM,EACNyD,UAAW,UACX9I,MAAO,MACPC,OAAQ,MACR,YAAa,CACX8I,YAAa,gBACbC,YAAY,2BAAD,OAA6BjE,EAAMkE,QAAQC,KAAK,KAAhD,kBAGf,+BAAgC,CAC9BC,OAAQ,EACR9D,KAAM,EACN+D,aAAc,UACdpJ,MAAO,MACPC,OAAQ,MACR,YAAa,CACX8I,YAAa,gBACbC,YAAY,GAAD,OAAKjE,EAAMkE,QAAQC,KAAK,KAAxB,0CAGf,iCAAkC,CAChC7D,KAAM,EACN+C,WAAY,UACZnI,OAAQ,MACRD,MAAO,MACP,YAAa,CACX+I,YAAa,gBACbC,YAAY,eAAD,OAAiBjE,EAAMkE,QAAQC,KAAK,KAApC,8BAGf,gCAAiC,CAC/BG,MAAO,EACPC,YAAa,UACbrJ,OAAQ,MACRD,MAAO,MACP,YAAa,CACX+I,YAAa,gBACbC,YAAY,uCAAD,OAAyCjE,EAAMkE,QAAQC,KAAK,cAiJhEK,EA3IQ,SAACtE,GAAW,IAAD,EAC1BO,EAAUX,EAAUI,GACpBuE,EAAK/E,kBAAQgF,KAAKC,OAAQ,IAFA,EAIAnL,mBAAS,MAJT,mBAIzBoL,EAJyB,KAIfC,EAJe,OAKArL,mBAAS,MALT,mBAKzBsL,EALyB,KAKfC,EALe,KAO1BC,EAAoB3J,uBAAY,SAAC4J,GACrCJ,EAAYI,EAAMC,iBACjB,IAEGC,EAAc9J,uBAAY,WAAQwJ,EAAY,QAAS,IAEvDO,EAAoB/J,sBAAW,sBAAC,sBAAAU,EAAA,uEACXmE,EAAMmF,SAAWlC,KADN,QAGnB,IAHmB,QAIlCgC,IAJkC,2CAMnC,CAACA,EAAajF,EAAMmF,UAEjBC,EAAsBjK,uBAAY,SAAC4J,IACtC/E,EAAMqF,iBAAmBpC,GAAM8B,EAAMvD,OAAO7B,MAAOuF,KACnD,CAAClF,EAAMqF,gBAAiBH,IAErBI,EAAwBnK,uBAAY,SAACwE,GAAD,8CAAW,WAAOoF,GAAP,SAAAlJ,EAAA,yDACzB,aAAtBkJ,EAAMvD,OAAOQ,KADkC,kEAK1BhC,EAAMuF,UAAYtC,GAAMtD,GALE,QAOlC,IAPkC,QAQjDuF,IARiD,2CAAX,wDAUvC,CAACA,EAAmBlF,EAAMuF,WAEvBC,IAAUd,EAEhB,OACE,yBAAKlE,UAAWD,EAAQR,MACtB,kBAAC+B,EAAA,EAAD,eACE2D,eAAa,EACb5C,QAAQ,WACR6C,gBAAc,OACdlF,UAAWD,EAAQoF,OACnB1D,QAAS6C,EACTc,gBAAA,2BAAmCrB,IAC9BvE,EAAM6F,aAETL,GAAQxF,EAAM8F,aAA8B9F,EAAM+F,MAClDP,EACE,kBAAC,IAAD,CAAiBhF,UAAWD,EAAQ2C,YACpC,kBAAC,IAAD,CAAmB1C,UAAWD,EAAQ2C,aAG5C,kBAAC8C,EAAA,EAAD,eACEC,aAAW,EACXT,KAAMA,EACNU,UAAW,EACXxB,SAAUA,EACVyB,mBAAoB,KACpBhB,QAASD,EACTX,GAAE,2BAAsBA,GACxBhE,QAAS,CAAEmD,MAAOnD,EAAQmD,OAC1B0C,aAAc,CAACC,SAAU,SAAUC,WAAY,UAC/CC,gBAAiB,CAACF,SAAU,MAAOC,WAAY,WAC1CtG,EAAMwG,WAXb,UAaGxG,EAAMyG,eAbT,aAaG,EAAe7I,KAAI,WAAuE8I,GAAO,IAA3E1D,EAA0E,EAA1EA,IAAKrD,EAAqE,EAArEA,MAAOgH,EAA8D,EAA9DA,KAAMC,EAAwD,EAAxDA,SAAUC,EAA8C,EAA9CA,aAAcC,EAAgC,EAAhCA,QAASC,EAAuB,EAAvBA,cACpEC,EAAqB,KAEzB,GAAuB,mBAAZF,EAAuB,CAChC,IAAMG,EAAY,kBAACC,EAAA,EAAD,CAAUJ,QAASA,EAAS7E,QAASmD,EAAqBzF,WAAyBnD,IAAlBuK,EAA8BpH,EAAQoH,IACnHI,EAAeN,GAAgB7G,EAAM6G,aAE3CG,EAAqBG,EACnB,kBAACC,EAAA,EAAD,CACE7G,QAAS,CAAE6C,QAAS7C,EAAQ6C,QAASQ,OAAQrD,EAAQqD,QACrDyD,YAAa,CACXC,cAAe,CACbC,UAAW,CACTjE,MAAO,CACLkE,UAAW5C,EACX6C,QAAS7C,MAKjBmB,MACE,kBAAC,IAAM2B,SAAP,KACGP,EACD,0BAAM3G,UAAWD,EAAQ+C,MAAO5C,IAAKmE,KAGzC8C,gBAAwCnL,IAA5BwD,EAAM4H,kBAAkC,IAAM5H,EAAM4H,kBAChEC,WAAY7H,EAAM8H,mBAAqB,EACvCC,aAAW,WACXC,UAAWhI,EAAMiI,kBAAoB,OAEpChB,GAEDA,EAGN,OACE,kBAACnE,EAAA,EAAD,eACEE,IAAKA,GAAO0D,EACZzE,QAASqD,EAAsB3F,GAC/BiH,SAAUA,GACN5G,EAAMkI,eAETlB,EACD,kBAACmB,EAAA,EAAD,CAAcC,QAASzB,IAAI,OAAIhH,QAAJ,IAAIA,OAAJ,EAAIA,EAAO0I,qBCjM9CzI,EAAYC,aAAW,SAACC,GAAD,MAAY,CACvCC,KAAM,SAACC,GAAD,MAAY,QAwELsI,EApEM,SAACtI,GAAW,IAAD,EACxBM,EAAS7H,IACT8H,EAAUX,EAAU,2BAAKI,GAAUM,IAEnCiI,EAAiB/I,mBAAQ,WAC7B,IAAIgJ,EAAkB,CAAE/L,SAAU,KAAMiB,MAAO,KAAM+K,MAAM,GAE3D,OAAKnI,EAAOjG,iBAIZiG,EAAOzG,QAAQ6O,MAAK,SAACC,GACnB,OAAIA,EAAOlM,WAAa6D,EAAOjG,kBAC7BmO,EAAkBG,GAEX,MAMJH,GAbEA,IAcR,CAAClI,EAAOzG,QAASyG,EAAOjG,kBAErBuO,EAAqBzN,uBAAY,SAACsB,GAClC6D,EAAOjG,kBAAoBoC,GAC7B6D,EAAOb,MAAM,CAAEhD,eAEhB,CAAC6D,IAEEuI,EAAyB1N,uBAAY,SAACsB,GACtC6D,EAAO/F,oBAAsBkC,EAC/B6D,EAAOjC,0BAEPiC,EAAOpC,qBAAqBzB,GAC5BmM,EAAmBnM,MAEpB,CAAC6D,EAAQsI,IAEZ,OACE,yBAAKpI,UAAWD,EAAQR,MACtB,kBAAC,EAAD,CACE+F,YAAY,gBACZC,OAAO,UAAAzF,EAAOzG,eAAP,eAAgByF,QACnBiJ,EAAe7K,OAAS,qBACxB,sBAEJ6H,SAAUqD,EACVvD,gBAAiBwD,EACjBpC,QAASnG,EAAOzG,QAAQ+D,KAAI,SAAA+K,GAAM,MAAK,CACrC3F,IAAK2F,EAAOjL,MACZiC,MAAOgJ,EAAOlM,SACdkK,KAAMgC,EAAOjL,OAAS,iBACtBkJ,SAAU+B,EAAOlM,WAAa6D,EAAOjG,gBACrCyM,QAAUxG,EAAO/F,oBAAsBoO,EAAOlM,SAC9CoK,aAAevG,EAAO/F,oBAAsBoO,EAAOlM,SAC/C,iBACA,sB,kBC9DRmD,EAAYC,aAAW,SAAAC,GAAK,MAAK,CACrCgJ,MAAO,CACLC,QAASjJ,EAAMwC,QAAQ,IAEzB0G,YAAa,GAEbC,UAAW,CACTnI,QAAS,OACToI,SAAU,WACVC,eAAgB,gBAElBC,aAAc,CACZrO,MAAO,IACPgO,QAASjJ,EAAMwC,QAAQ,IACvBuB,UAAW/D,EAAMwC,QAAQ,IACzB+G,UAAW,SAEbxK,IAAK,CACHyK,WAAY,QACZvO,MAAO,YAqCIwO,EAjCM,SAACvJ,GACpB,IAAMO,EAAUX,IAER4J,EAAYxJ,EAAZwJ,QAER,QAAUA,EAAQlK,QAChB,oCACE,kBAACmK,EAAA,EAAD,CAAOjJ,UAAWD,EAAQuI,OACxB,yBAAKtI,UAAWD,EAAQyI,aACtB,kBAACU,EAAA,EAAD,CAAY7G,QAAQ,KAAKd,UAAU,MAAnC,WAGA,kBAAC2H,EAAA,EAAD,CAAY3H,UAAU,KAAtB,YACYyH,EAAQG,QAAO,SAACC,EAAD,UAAmBA,EAAnB,EAAOC,QAA0B,GAAKL,EAAQlK,SAG3E,wBAAIkB,UAAWD,EAAQ0I,WACpBO,EAAQ5L,KAAI,WAAqB8I,GAArB,IAAGmD,EAAH,EAAGA,MAAOnL,EAAV,EAAUA,QAAV,OACX,wBAAI8B,UAAWD,EAAQ6I,aAAcpG,IAAKtE,GACxC,kBAACgL,EAAA,EAAD,KAAaG,GACb,yBAAK9K,IAAKL,EAAS8B,UAAWD,EAAQ1B,IAAKiL,IAAG,gBAAWpD,a,2BCxCjE9G,GAAYC,aAAW,SAAAC,GAAK,MAAK,CACrCgJ,MAAO,CACLC,QAASjJ,EAAMwC,QAAQ,IAEzB0G,YAAa,CACXlI,QAAS,OACTiJ,WAAY,SACZZ,eAAgB,gBAChBhF,aAAcrE,EAAMwC,QAAQ,IAE9B2G,UAAW,CACTnI,QAAS,OACToI,SAAU,WACVC,eAAgB,gBAElBC,aAAc,CACZrO,MAAO,IACPuO,WAAY,QACZP,QAASjJ,EAAMwC,QAAQ,IACvBuB,UAAW/D,EAAMwC,QAAQ,IACzBrC,SAAU,WACV,UAAW,CACT,UAAW,CACTqJ,WAAY,wBAIlBzK,IAAK,CACH9D,MAAO,OACPuO,WAAY,iBAEdU,WAAY,CACVlJ,QAAS,OACTmJ,WAAY,YACZhK,SAAU,WACVE,IAAK,EACL+D,OAAQ,EACRnJ,MAAO,OACPqF,KAAM,EACN+I,eAAgB,SAChBY,WAAY,SACZ,UAAW,CACT,aAAc,CACZjJ,QAAS,aAIfoJ,QAAS,CACPpJ,QAAS,OACTqJ,MAAO,QACPC,gBAAiB,wBACjB,UAAW,CACTA,gBAAiB,0BAEnB,sBAAuB,CACrBA,gBAAiB,8BAmDRC,GA9CO,SAACrK,GACrB,IAAMO,EAAUX,KAER0K,EAAiBtK,EAAjBsK,aAER,QAAUA,EAAaxB,MAAMxJ,QAC3B,oCACE,kBAACmK,EAAA,EAAD,CAAOjJ,UAAWD,EAAQuI,OACxB,yBAAKtI,UAAWD,EAAQyI,aACtB,kBAACU,EAAA,EAAD,CAAY7G,QAAQ,KAAKd,UAAU,MAAnC,mBAGA,6BACE,kBAACD,EAAA,EAAD,CAAQG,QAASqI,EAAaC,eAA9B,YAGA,kBAACzI,EAAA,EAAD,CAAQG,QAASqI,EAAaE,gBAA9B,eAKJ,wBAAIhK,UAAWD,EAAQ0I,WACpBqB,EAAaxB,MAAMlL,KAAI,WAAmB8I,GAAnB,IAAShI,EAAT,EAAE+L,OAAF,OACtB,wBAAIjK,UAAWD,EAAQ6I,aAAcpG,IAAKtE,GACxC,yBAAK8B,UAAWD,EAAQyJ,YACtB,kBAACU,EAAA,EAAD,CACEzS,KAAMyO,EACNlG,UAAWD,EAAQ2J,QACnBjI,QAASqI,EAAaN,YAEtB,kBAAC,IAAD,CAAmBzG,SAAS,YAGhC,yBAAKxE,IAAKL,EAAS8B,UAAWD,EAAQ1B,IAAKiL,IAAG,gBAAWpD,aCrGjEiE,GAAQxS,OAAOyS,gBCERC,GAAc,WACzB,IAAMC,EAAW1R,mBACX2R,EDFiB,WAAO,IAAD,EACDzR,mBAAS,MADR,mBACtB0R,EADsB,KACdC,EADc,OAEH3R,mBAAS,MAFN,mBAEtB4R,EAFsB,KAEfC,EAFe,KAI7B1Q,qBAAU,WACR,IAAKuQ,EAAQ,CACX,IAAMI,EAAYT,GAAMU,YACxBJ,EAAUG,GACVD,EAASC,EAAU,OAEpB,CAACJ,IAEJ,IAAMM,EAAMnQ,uBAAY,SAACwL,GACvB,IAAM4E,EAAY,IAAIC,yBAAyB7E,GAC/C4E,EAAUL,MAAQA,EAClBP,GAAMc,MAAMF,KACX,CAACL,IAEEQ,EAAYvQ,uBAAY,SAACuG,GAAgC,IAAD,yDAAP,GAAhBiK,EAAuB,EAAvBA,MAAOC,EAAgB,EAAhBA,OACxCD,GAAOE,WAAWF,EAAc,IAAPjK,GAC7BD,MAAMC,KAAK,CAAEpC,OAAQoC,IAClBlG,SAAQ,SAACuH,EAAGjF,GACX,IAAMgO,EAAMpK,EAAO5D,EACnB+N,YAAW,WACTP,EAAIQ,GACAF,GAAQA,EAAOE,KACZ,IAANhO,QAEN,CAACwN,IAEJ,MAAO,CAAEA,MAAKI,aC5BCK,GAETC,EAAW7Q,uBAAY,WASjB,IAAD,yDAAP,GARF8Q,EAQS,EARTA,iBACAC,EAOS,EAPTA,MACAP,EAMS,EANTA,MACAQ,EAKS,EALTA,QAKS,IAJTC,mBAIS,MAJK,IAIL,MAHTC,oBAGS,MAHM,IAGN,MAFTC,oBAES,aADTC,uBACS,SACLL,IAAUpB,EAASpQ,UACrBoQ,EAASpQ,QAAU,CACjBuR,mBACAO,kBAAkB,EAClBC,iBAAiB,EACjBP,QACAP,QACAQ,UACAO,QAAS,EACTN,cACAC,eACAC,eACAC,sBAGH,IAEGI,EAAYxR,sBAAW,uCAAC,yCAAAU,EAAA,yDAAS+Q,EAAT,EAASA,KAAMtM,EAAf,EAAeA,OAAQuM,EAAvB,EAAuBA,QAASnR,EAAhC,EAAgCA,MAExDoP,EAASpQ,QAFe,qBAKtBoQ,EAASpQ,QAAQuR,kBAAqBnB,EAASpQ,QAAQ8R,iBALjC,qBAMpB1B,EAASpQ,QAAQ+R,gBANG,wDAQtB3B,EAASpQ,QAAQ+R,iBAAkB,EARb,UAUhB3B,EAASpQ,QAAQuR,iBAAiB,CAAEW,OAAMtM,SAAQuM,UAASnR,SAV3C,eAWtBoP,EAASpQ,QAAQ8R,kBAAmB,EACpCI,EAAKE,eAZiB,+BAiBtBhC,EAASpQ,QAAQyR,SAAYrB,EAASpQ,QAAQgS,UAAY5B,EAASpQ,QAAQyR,QAjBrD,qBAkBpBrB,EAASpQ,QAAQiR,MAlBG,kCAmBhBb,EAASpQ,QAAQiR,MAAM,CAAEiB,OAAMtM,SAAQuM,UAASnR,SAnBhC,eAsBxBoP,EAASpQ,QAAU,KAtBK,kBAuBjBgB,KAvBiB,WA0BpBqR,EAAgBvI,KAAKwI,MAAMJ,EAAKK,QAAU,KAG1CvB,EAAYlH,KAAK0I,IAAKpC,EAASpQ,QAAQ0R,YAAc,IAAQW,EAAe,GAG9EjC,EAASpQ,QAAQ4R,gBACX/S,EAAQ+G,EAAR/G,KACJ4T,KAAO,aACX5T,EAAI6T,UAAY,QAChB7T,EAAI6B,UAAU,EAAG,EAAG,GAAI,IAEpBsQ,GACFnS,EAAI8T,SAAS3B,EAAW,GAAI,KAK5BA,GAAaZ,EAASpQ,QAAQ6R,iBAAmBzB,EAASpQ,QAAQ4S,aAAe5B,IACnFZ,EAASpQ,QAAQ4S,WAAa5B,EAC9BX,EAAOO,IAAP,UAAcI,OAKZkB,EAAKK,SAAWnC,EAASpQ,QAAQ0R,cAAgBtB,EAASpQ,QAAQ6S,cAnD5C,wBAoDxBzC,EAASpQ,QAAQgS,UACjB5B,EAASpQ,QAAQ6S,eAAgB,EACjCzC,EAASpQ,QAAQ8S,iBAAkB,EAtDX,UAuDlB1C,EAASpQ,QAAQwR,MAAM,CAAEU,OAAMtM,SAAQuM,UAASnR,OAAM+R,OAAQ3C,EAASpQ,QAAQgS,UAvD7D,QAwDxB5B,EAASpQ,QAAQ8S,iBAAkB,EAxDX,wBAyDfZ,EAAKK,SAAYnC,EAASpQ,QAAQ0R,YAActB,EAASpQ,QAAQ2R,cAAiBvB,EAASpQ,QAAQ8S,kBAK5GZ,EAAKE,eACLhC,EAASpQ,QAAQ6S,eAAgB,EACjCzC,EAASpQ,QAAQ8S,iBAAkB,GAhEX,4CAAD,sDAmE1B,CAACzC,IAEE2C,EAAQvS,uBAAY,WACxB2P,EAASpQ,QAAU,OAClB,IAEH,OAAO8E,mBAAQ,iBAAO,CACpBkO,QACA1B,WACAW,eACE,CACFe,EACA1B,EACAW,K,UC5GEgB,G,OAAgBC,KCHTC,GAAiBrV,0BAEjBsV,GAAa,WACxB,IAAMpV,EAAQC,qBAAWkV,IAIzB,QAAcrR,IAAV9D,EACF,MAAM,IAAIE,MAAM,oDAGlB,OAAOF,GAaMqV,GAVS,SAAC,GAAgB,IAAf7U,EAAc,EAAdA,SAClBqG,EDV4B,WAClC,IAAMe,EAAS7H,IAETuV,EAAU5U,mBACV6U,EAAa7U,mBAJqB,EAKRE,oBAAS,GALD,mBAKjC4U,EALiC,KAKvBC,EALuB,OAMA7U,oBAAS,GANT,mBAMjC8U,EANiC,KAMnBC,EANmB,KASxC5T,qBAAU,YACHuT,EAAQtT,SAAW4F,EAAO3G,QAC7BqU,EAAQtT,SAAU,EAClBiT,GAAcW,OACXnR,MAAK,WACJrB,QAAQK,IAAI,kBACZgS,GAAY,MAEbI,MAAMzS,QAAQC,UAElB,CAACuE,IAGJ,IAAMuM,EAAU1R,sBAAW,sBAAC,4BAAAU,EAAA,yDACrBqS,EADqB,sBAElB,IAAItV,MAAM,8DAFQ,uBAKC+U,GAAcd,QAAQvM,EAAOnB,uBAL9B,cAKpBqP,EALoB,yBASnBA,GATmB,2CAUzB,CAACN,EAAU5N,IAcd,OAXA7F,qBAAU,YACJyT,GAAaD,EAAWvT,SAAY0T,IACtCH,EAAWvT,SAAU,EACrBmS,IACG1P,MAAK,WACJkR,GAAgB,SAGrB,CAACxB,EAASqB,EAAUE,IAGhBA,EAAevB,EAAU,KCpChB4B,GAEhB,OACE,kBAACZ,GAAenO,SAAhB,CAAyBC,MAAOJ,GAC7BrG,IChBMwV,GAAU,SAACC,GACtB,IAAMrO,EAAS7H,IACToU,EAAUiB,KAEVc,ECTmB,WACzB,IAAMC,EAAczV,mBACd0V,EAAe1V,mBACf2V,EAAiB3V,mBACjB4V,EAAY5V,mBACZ6T,EAAU7T,mBAEV6V,EAAQ9T,uBAAY,WAAkB,IAAjB+T,EAAgB,uDAAN,EACnCJ,EAAapU,QAAUwU,EACvBL,EAAYnU,QAAUwU,EACtBF,EAAUtU,QAAU,EACpBqU,EAAerU,QAAU,EACzBuS,EAAQvS,QAAU,IACjB,IAEGoS,EAAe3R,uBAAY,WAC/B8R,EAAQvS,QAAU,IACjB,IAEGyU,EAAShU,uBAAY,SAAC+T,GAC1B,IAAIE,GAAQ,EACPN,EAAapU,UAChB0U,GAAQ,EACRH,EAAMC,IAGR,IAAMG,EAAYH,EAAYL,EAAYnU,QAC1CuS,EAAQvS,SAAW2U,EAEnB,IAAIC,EAAM,EACNC,EAAS,EAGTR,EAAerU,YACjB4U,EAAM,IAAOD,EACbE,EAASP,EAAUtU,QAAUqU,EAAerU,QAC5CsU,EAAUtU,SAAW4U,GAGvB,IAAME,EAAUN,EAAYJ,EAAapU,QAGzC,OAFAmU,EAAYnU,QAAUwU,EAEf,CACLE,QACAF,YACAI,MACAC,SACAC,UACAC,OAAQV,EAAerU,QACvBuS,QAASA,EAAQvS,QACjBoS,kBAED,CAACmC,EAAOnC,IAIX,OAFmBtN,mBAAQ,iBAAO,CAAE2P,SAAQF,WAAU,CAACE,EAAQF,ID7C9CS,GACX5E,EAAWD,KAEX8E,EAAavW,mBACbwW,EAAgBxW,mBARe,EASPE,oBAAS,GATF,mBAS9BuW,EAT8B,KASrBC,EATqB,KAY/BC,EAAe5U,uBAAY,WAE/B2P,EAAS4C,QACTkB,EAASK,QACTU,EAAWjV,SAAU,EACrBoV,GAAW,KACV,CAAClB,EAAU9D,IAIRkF,EAAc7U,uBAAY,WAC9BwU,EAAWjV,SAAU,EACrBoV,GAAW,KACV,IAIGG,EAAO9U,sBAAW,uCAAC,WAAO+T,GAAP,iBAAArT,EAAA,6DACjB+Q,EAAOgC,EAASO,OAAOD,GADN,SAEDU,EAAclV,QAAQ,CAC1CkS,OACAtM,SACAuM,UACAb,SAAUlB,EAASkB,SACnBtQ,KAAMsU,IAPe,OAEjBE,EAFiB,OAUvBpF,EAAS6B,UAAU,CACjBC,OACAtM,SACAuM,UACAnR,KAAMsU,IAGJL,EAAWjV,QACbyV,sBAAsBF,IAEtBD,IACAJ,EAAclV,QAAU,KACxB4F,EAAOjF,cACH6U,GAASA,KAvBQ,2CAAD,sDAyBrB,CACD5P,EACAuM,EACA/B,EACA8D,EACAoB,IAGIvQ,EAAQtE,sBAAW,uCAAC,WAAOwT,GAAP,SAAA9S,EAAA,0DACpB8T,EAAWjV,QADS,sBAEhB,IAAI9B,MAAM,+BAFM,UAGZiU,EAHY,sBAIhB,IAAIjU,MAAM,sCAJM,UAKZ+V,EALY,uBAMhB,IAAI/V,MAAM,sDANM,eASxBgX,EAAclV,QAAUiU,EACxBoB,IAVwB,kBAYjBI,sBAAsBF,IAZL,4CAAD,sDAatB,CAACA,EAAMpD,EAASkD,IAenB,OAbmBvQ,mBAAQ,iBAAO,CAChCC,QACAoQ,UACAnU,KAAMsU,EACNrW,MAAOkT,GAAWvM,EAAO3G,SACvB,CACF8F,EACAoN,EACAgD,EACAG,EACA1P,EAAO3G,S,mDE7EEyW,I,OAA4C,SAAC5B,EAAc6B,GAKtE,IALmF,IAC5EC,EAAuB9B,EAAvB8B,KAAMvV,EAAiByT,EAAjBzT,MAAOC,EAAUwT,EAAVxT,OACduV,EAAc,IAAIC,kBAA6C,EAA3BhC,EAAa8B,KAAKhR,QAGnDoH,EAAI,EAAGA,EAAI1L,EAASD,IAAS2L,EAAG,CACvC,IAAM+J,EAAI/J,EAAI3L,EACR2V,EAAIC,SAASjK,EAAI3L,GAEjB6V,EAAWN,EAAK5J,GAChBmK,EAAgBR,EAAWtV,EAAQ0V,EAAM1V,EAAQ2V,EAAKhK,EAE5D6J,EAAwB,EAAZM,GAAiBD,EAAW,IAAM,EAC9CL,EAAwB,EAAZM,EAAc,GAAKD,EAAW,IAAM,EAChDL,EAAwB,EAAZM,EAAc,GAAKD,EAAW,IAAM,EAChDL,EAAwB,EAAZM,EAAc,GAAKD,EAAW,IAAM,EAElD,IAAIE,EAAkB,IAAIC,UAAUR,EAAaxV,EAAOC,GAGpDgW,EAAUC,GAAGC,iBAAiBJ,GAG9BK,EAAa,IAAIF,GAAGG,UACxBH,GAAGI,MAAML,EAASG,GAClB,IAAIG,EAAW,IAAIL,GAAGM,IAEtBN,GAAGO,UAAUL,EAAWM,IAAI,GAAIH,EAAU,IAAK,EAAGL,GAAGS,eAKrD,IAAIC,EAAW,IAAIV,GAAGG,UAClBQ,EAAY,IAAIX,GAAGM,IACvBN,GAAGY,aAAaP,EAAUK,EAAUC,EAAWX,GAAGa,WAAYb,GAAGc,qBAIjE,IAHA,IAAIC,EAAOf,GAAGM,IAAIU,MAAMX,EAASY,KAAMZ,EAASa,KAAMlB,GAAGmB,SAGhD1L,EAAI,EAAGA,EAAIiL,EAASU,SAAU3L,EAC9BuK,GAAGqB,YAAYX,EAASF,IAAI/K,IAFd,KAInBuK,GAAGsB,aAAaP,EAAML,EAAUjL,EAAG,CAAC,EAAG,EAAG,EAAG,IAAK,EAAWuK,GAAGuB,OAAQZ,EAAW,KAMvF,IAAIa,EAAUxB,GAAGM,IAAIU,MAAMjB,EAAQkB,KAAMlB,EAAQmB,KAAMlB,GAAGyB,SAC1DzB,GAAGI,MAAMoB,EAAStB,GAElBA,EAAWM,IAAI,GAAGkB,MAAM,CAAC,IAAK,EAAG,EAAG,GAAIX,GACxCb,EAAWM,IAAI,GAAGkB,MAAM,CAAC,IAAK,EAAG,EAAG,GAAIX,GAExC,IACIY,EAAa,IAAI3B,GAAGM,IACpBsB,EAAI5B,GAAGM,IAAIuB,KAFE,MAE2B7B,GAAG8B,OAC3CC,EAAS,IAAI/B,GAAGgC,OAAO,GAAI,GAC/BhC,GAAGiC,OAAOlB,EAAMY,EAAYC,EAAGG,EAAQ,EAAG/B,GAAGkC,gBAAiBlC,GAAGmC,gCACjEnC,GAAGoC,SAAST,EAAYZ,EAAMY,GAE9BzB,EAAWM,IAAI,GAAGkB,MAAM,CAAC,IAAK,EAAG,EAAG,GAAIC,GACxCzB,EAAWM,IAAI,GAAGkB,MAAM,CAAC,IAAK,EAAG,EAAG,GAAIC,GAExC3B,GAAGqC,MAAMnC,EAAYsB,GACrB,IAAMc,EAAmB,IAAIxC,UAAU,IAAIP,kBAAkBiC,EAAQnC,MAAOmC,EAAQN,KAAMM,EAAQP,MAKlG,OAHAlB,EAAQwC,SAAUrC,EAAWqC,SAAUxB,EAAKwB,SAAUf,EAAQe,SAAUX,EAAEW,SAGnE,CAACD,mBAAkBzC,gBAAiByC,KAGhCE,GAAgD,SAACC,EAAiBlF,EAAc6B,GAO3F,IAPwG,IACjGC,EAAuB9B,EAAvB8B,KAAMvV,EAAiByT,EAAjBzT,MAAOC,EAAUwT,EAAVxT,OACd2Y,EAAQ,IAAInD,kBAA6C,EAA3BhC,EAAa8B,KAAKhR,QAElDsU,EAAQ,EACRC,EAAe,EAEVnN,EAAI,EAAGA,EAAI1L,EAASD,IAAS2L,EAAG,CACvC,IAAM+J,EAAI/J,EAAI3L,EACR2V,EAAIC,SAASjK,EAAI3L,GAEjB8V,EAAgBR,EAAWtV,EAAQ0V,EAAM1V,EAAQ2V,EAAKhK,EAEtDkK,EAAWN,EAAK5J,GAChBoN,IAAgBJ,EAAgBpD,KAAiB,EAAZO,EAAc,GACnDkD,EAAiBD,GAAelD,EAChCoD,EAAkBF,IAAgBlD,EAClCqD,GAAwBH,GAAelD,EACvCsD,EAAiBD,GAAwBF,GAAkBC,EAE7DD,GAAgBF,KAChBjD,GAAYkD,IAAaF,IAE7BD,EAAkB,EAAZ9C,GAAiBoD,EAAuB,IAAM,EACpDN,EAAkB,EAAZ9C,EAAc,GAAKkD,EAAgB,IAAM,EAC/CJ,EAAkB,EAAZ9C,EAAc,GAAKmD,EAAkB,IAAM,EACjDL,EAAkB,EAAZ9C,EAAc,GAAKqD,EAAgB,IAAM,EAMjD,MAAO,CAAErK,MAHKrF,KAAK2P,MAAMN,GAAgBD,EAAM,MAAa,KAG5CnB,QAFA,IAAI1B,UAAU4C,EAAO5Y,EAAOC,KC/GjCoZ,GAAgB,WAC3B,IAAMC,EAAUjb,mBACVkH,EAAS7H,IAFkB,EAGHa,oBAAS,GAHN,mBAG1Bgb,EAH0B,KAGjBC,EAHiB,KAK3BC,ECTsB,WAAO,IAAD,EACRlb,mBAAS,IADD,mBAC3BwP,EAD2B,KACpB2L,EADoB,KAG5BC,EAAUtb,iBAAO,MACjBub,EAAavb,iBAAO,GAEpB6V,EAAQ9T,uBAAY,WACxBwZ,EAAWja,QAAU,EACrBga,EAAQha,QAAU,OACjB,IAEGka,EAAOzZ,uBAAY,WACvB,IAAM0Z,EAAc/L,EAAM6L,EAAWja,SAErC,OAAKma,GAOLH,EAAQha,QAAUma,EAClBF,EAAWja,UAEJma,IATLH,EAAQha,QAAU,KAClBia,EAAWja,QAAU,EAEd,QAOR,CAACoO,IAEJ,OAAOtJ,mBAAQ,iBAAO,CACpBoV,OACA3F,QACAyF,UACAD,WACAK,SAAUhM,EAAMxJ,UACd,CACFsV,EACA3F,EACAnG,ID3BmBiM,GALY,EAMLzb,mBAAS,IANJ,mBAM1B0b,EAN0B,KAMlBC,EANkB,OAOS3b,mBAAS,MAPlB,mBAO1B4b,EAP0B,KAOXC,EAPW,KAU3BC,EAAYja,sBAAW,uCAAC,WAAOka,GAAP,mBAAAxZ,EAAA,6DAC5B0Y,GAAW,GADiB,SAETe,KAAMC,UAAUF,GAFP,cAEtB/E,EAFsB,gBAGAxT,QAAQC,IAAIuT,EACnC9S,QAAO,SAACvF,GAAD,OAAUA,EAAKud,SAAS,WAC/B5X,KAAI,gBAAG3F,EAAH,EAAGA,KAAH,OAAcqY,EAAK+E,KAAKpd,GAAMwd,MAAM,cALjB,cAGpBC,EAHoB,gBAQK5Y,QAAQC,IAAI2Y,EACxC9X,KAAI,SAAA+X,GAAG,OAAIrV,EAAO1B,mBAAP,gCAAmD+W,QATvC,OAQpBC,EARoB,OAY1BpB,EAAaC,SAASmB,GACtBrB,GAAW,GAbe,4CAAD,sDAc1B,CAACC,EAAclU,IAEZuV,EAAsB1a,uBAAY,YAAa,IAAXka,EAAU,oBAChC,oBAAdA,EAAKrT,MAKToT,EAAUC,GACVF,EAAiB,OALfrZ,QAAQC,MAAM,8BAA+BsZ,EAAKrT,QAMnD,CAACoT,IAEEU,EAAyB3a,sBAAW,uCAAC,+BAAAU,EAAA,yDAA0Bka,EAA1B,EAASvU,OAAU7B,MAAnB,uBAEvCwV,EAAiB,MAFsB,0CAMtB,IAAIG,KAAMU,SAASlZ,SAAQ,SAACE,EAASiZ,GACtDC,KAAWC,iBAAiBC,6BAAA,iBAAmCL,IAAY,SAACM,EAAK/F,GACzE+F,EAAKJ,EAAOI,GACXrZ,EAAQsT,SATsB,OAMnC+E,EANmC,OAa3CD,EAAUC,GACVF,EAAiBY,GAd0B,2CAAD,sDAevC,CAACX,IAEEzG,EAAaxT,sBAAW,uCAAC,WAAOmb,GAAP,SAAAza,EAAA,6DACzBya,EAAW1J,KAAKwC,QAClBoF,EAAaI,OACbK,EAAU,IACVqB,EAAWtK,SAAS,CAClBG,QAASqI,EAAaM,SACtBxI,cAAc,EACdC,iBAAiB,EACjBH,YAAa,IACbmK,YAAa,IACbrK,MAAO,YAA8B,IAA3BW,EAA0B,EAA1BA,QAAenR,GAAW,EAAjBkR,KAAiB,EAAXlR,MACjB8F,EAASgT,EAAaE,QAAQha,QAIpC,IAAK8G,EAAQ,OAAO9F,IAEpB2Y,EAAQ3Z,QAAUmS,EAAQvM,EAAOnH,SAASuB,SACvCyC,KADe,uCACV,WAAMqR,GAAN,qBAAA3S,EAAA,wDACuB4X,GAA8CjS,EAAQgN,EAAclO,EAAO7G,OAA9FoQ,EADJ,EACIA,MAAO4I,EADX,EACWA,QAET/T,EAAU4B,EAAO/B,mBAAmBkU,GAC1CwC,GAAU,SAAAvc,GAAK,6BAAQA,GAAR,CAAe,CAAEmR,QAAOnL,gBAEvC4B,EAAOjF,cACPmZ,EAAaI,OAPT,2CADU,2DAcpBJ,EAAaE,QAAQha,SACvB4F,EAAO/G,IAAIkF,aAAa+V,EAAaE,QAAQha,QAAS,EAAG,GAhC9B,mBAsCtB,WACD2Z,EAAQ3Z,QAAS2Z,EAAQ3Z,QAAQyC,KAAKmZ,EAAWhW,OAAOjF,aACvDib,EAAWhW,OAAOjF,iBAxCI,2CAAD,sDA0C3B,CAACiF,EAAQkU,IAEZ,OAAOhV,mBAAQ,iBAAO,CACpBwV,SACAV,UACA3F,aACAuG,gBACAW,sBACAC,yBACAnc,QAAS6a,EAAaM,YACpB,CACFE,EACAV,EACA3F,EACA6F,EACAU,EACAW,EACAC,K,qBE9GSU,GAAkB,WAC7B,IAAMnC,EAAUjb,mBADmB,EAETE,mBAAS,IAFA,mBAE5BwP,EAF4B,KAErB2L,EAFqB,KAI7BzK,EAAa7O,uBAAY,YAAuC,IAAb2C,EAAY,EAAnCkH,cAAiB/M,KAEjDwc,GAAS,SAAA/b,GAAK,OAAIA,EAAM8E,QAAO,SAACuF,EAAG0T,GAAJ,OAAcA,KAAW3Y,UACvD,IAEG0M,EAAiBrP,uBAAY,WACjCsZ,EAAS,MACR,IAEGlK,EAAgBpP,uBAAY,WAChC,IAAMub,EAAM,IAAIpB,KACVzW,EAAM6X,EAAIC,OAAO,SACvB7N,EAAMtN,SAAQ,WAAiBsC,GAAS,IAAhBkU,EAAe,EAAvBS,QACd5T,EAAIwW,KAAJ,eAAiBvX,EAAjB,QAA4B8Y,KAAaC,OAAO7E,GAAM8E,WAAY,CAACC,QAAQ,OAG7EL,EAAIM,cAAc,CAAChV,KAAK,SACrB7E,MAAK,SAAA8Z,GAAO,OH6GG,SAACC,EAAMnB,GAC3B,GAA0C,qBAA/Bjd,UAAUqe,iBACnB,OAAOre,UAAUqe,iBAAiBD,EAAMnB,GACnC,GAAoC,qBAAzBjd,UAAUse,WAC1B,OAAOte,UAAUse,WAAWF,EAAMnB,GAElC,IAAIsB,EAAOlf,OAAO0C,SAASC,cAAc,KACzCuc,EAAKC,KAAOnf,OAAOof,IAAIC,gBAAgBN,GACvCG,EAAKI,SAAW1B,EAChBsB,EAAKK,MAAQ,6CACZ7c,SAAS8c,MAAQ9c,SAAS+c,iBAAiBC,YAAYR,GAC9B,oBAAfA,EAAKS,MACdT,EAAKS,SAELT,EAAK7V,OAAS,SACd6V,EAAKU,cAAc,IAAIC,WAAW,QAAS,CACzCC,KAAM9f,OACN+f,SAAS,EACTC,YAAY,MAGhBZ,IAAIa,gBAAgBf,EAAKC,MGlINe,CAAOpB,EAAS,kBAClC,CAACnO,IAEE6F,EAAaxT,sBAAW,uCAAC,WAAOmb,GAAP,SAAAza,EAAA,6DACzBya,EAAW1J,KAAKwC,OAClBkH,EAAWtK,SAAS,CAClBM,cAAc,EACdC,iBAAiB,EACjBH,YAAa,IACbmK,YAAa,IAEbtK,iBAAiB,WAAD,4BAAE,6BAAApQ,EAAA,6DAASgR,EAAT,EAASA,QAAT,EAAkBvM,OAAlB,EAA0BsM,KAA1B,EAAgClR,KAAhC,kBACTmR,KADS,2CAAF,mDAAC,GAGjBX,MAAO,YAAsC,IAAnCW,EAAkC,EAAlCA,QAASvM,EAAyB,EAAzBA,OAAyB,EAAjBsM,KAAiB,EAAXlR,KAC/B2Y,EAAQ3Z,QAAUmS,EAAQvM,EAAOnH,SAASuB,SACvCyC,KADe,uCACV,WAAMqR,GAAN,uBAAA3S,EAAA,wDACwCuU,GAA0C5B,EAAclO,EAAO7G,OAApG8Z,EADH,EACGA,iBAAkBzC,EADrB,EACqBA,gBACnBwH,EAAiBhY,EAAO/B,mBAAmBgV,GAC3CgF,EAAgBjY,EAAO/B,mBAAmBuS,GAEhDxQ,EAAOjF,cACPiF,EAAO/G,IAAIkF,aAAa8U,EAAkB,EAAG,GAC7CkB,GAAS,SAAA/b,GAAK,6BAAQA,GAAR,CAAe,CAAC+Z,QAAS6F,EAAgB7N,OAAQ8N,QAP3D,2CADU,0DAZK,mBA6BtB,WACDlE,EAAQ3Z,QAAS2Z,EAAQ3Z,QAAQyC,KAAKmZ,EAAWhW,OAAOjF,aACvDib,EAAWhW,OAAOjF,iBA/BI,2CAAD,sDAiC3B,IAEH,OAAOmE,mBAAQ,iBAAO,CACpBsJ,QACA6F,aACA3E,aACAO,gBACAC,oBACE,CACF1B,EACA6F,EACA3E,EACAO,EACAC,KC9DE5K,GAAYC,aAAW,SAAAC,GAAK,MAAK,CACrCC,KAAM,CACJyY,SAAU,KACVnV,OAAQ,SACR0F,QAASjJ,EAAMwC,QAAQ,IAEzBmE,QAAS,CACP3F,QAAS,OACTiJ,WAAY,SACZ0O,cAAe,MACftP,eAAgB,gBAChBhF,aAAcrE,EAAMwC,QAAQ,QAI1BoW,GACK,UADLA,GAEQ,aA8ECC,GA3EF,SAAC3Y,GACZ,IAAMO,EAAUX,KAEVqQ,EAAOvB,KACPkK,EAAaxE,KACb9J,EAAekM,KACfqC,ECtCwB,WAC9B,IAAMvY,EAAS7H,IACToU,EAAUiB,KAUhB,OARoB3S,sBAAW,sBAAC,gCAAAU,EAAA,sEACHgR,EAAQvM,EAAOnH,SAASuB,SADrB,OACxB8T,EADwB,SAED4B,GAA0C5B,EAAclO,EAAO7G,OAApF8Z,EAFsB,EAEtBA,iBAERjT,EAAOjF,cACPiF,EAAO/G,IAAIkF,aAAa8U,EAAkB,EAAG,GALf,2CAM7B,CAAC1G,EAASvM,ID4BewY,GANN,EAOYxf,mBAAS,MAPrB,mBAOfyf,EAPe,KAOJC,EAPI,KAShBC,EAAkB9d,sBAAW,sBAAC,sBAAAU,EAAA,sDAC9BoU,EAAKJ,SACPI,EAAKvU,OACLsd,EAAa,QAEbA,EAAaN,IACbzI,EAAKxQ,MAAMmZ,EAAWjK,aANU,2CAQjC,CAACsB,EAAM2I,IAEJM,EAAqB/d,uBAAY,WACjC8U,EAAKJ,SACPI,EAAKvU,OACLsd,EAAa,QAEbA,EAAaN,IACbzI,EAAKxQ,MAAM6K,EAAaqE,eAEzB,CAACsB,EAAM3F,IAEV,OACE,yBAAK9J,UAAWD,EAAQR,MACtB,yBAAKS,UAAWD,EAAQkG,SACtB,kBAAC3E,EAAA,EAAD,CACEe,QAAQ,WACRZ,QAAS4W,EACTM,UAAWlJ,EAAKtW,OAASsW,EAAKJ,SAHhC,WAOA,kBAAC/N,EAAA,EAAD,CACEe,QAAQ,WACRZ,QAASiX,EACTC,UAAWlJ,EAAKtW,OAAUsW,EAAKJ,SAAWkJ,IAAcL,IAEtDzI,EAAKJ,SAAWkJ,IAAcL,GAAuB,OAAS,iBAElE,kBAAC,EAAD,CAAY1X,SAAU4X,EAAW9C,uBAAwBqD,UAAWlJ,EAAKtW,OAASsW,EAAKJ,QAASlQ,MAAOiZ,EAAW1D,gBAClH,kBAAC,EAAD,CACErS,QAAQ,WACR7B,SAAU4X,EAAW/C,oBACrBsD,UAAWlJ,EAAKtW,OAASsW,EAAKJ,SAAW+I,EAAWtE,SAEnDsE,EAAWtE,QAAU,aAAe,cAEvC,kBAACxS,EAAA,EAAD,CACEqI,MAAM,UACNtH,QAAQ,WACRZ,QAASgX,EACTE,WAAYlJ,EAAKtW,OAASif,EAAWjf,QAAWsW,EAAKJ,SAAWkJ,IAAcL,IAE3EzI,EAAKJ,SAAWkJ,IAAcL,GAA0B,OAAS,QAEtE,kBAAC,EAAD,OAEF,kBAAC,EAAD,MACA,kBAAC,GAAD,CAAepO,aAAcA,IAC7B,kBAAC,EAAD,CAAcd,QAASoP,EAAW5D,WE/FlClV,GAAQsZ,YAAe,CAC3B9P,WAAY,qDAkCC8M,OA/Bf,WAAgB,IAAD,EACiB9c,oBAAS,GAD1B,mBACN+f,EADM,KACGC,EADH,KAiBb,OAdA7e,qBAAU,WACR,IAAM8e,EAAWC,aAAY,WACvBrhB,OAAOkhB,UACTC,GAAW,GACXG,cAAcF,GACdzd,QAAQK,IAAI,mBAEb,KAEH,OAAO,WACLsd,cAAcF,MAEf,IAGD,kBAAC,IAAD,CAAkBzZ,MAAOA,IACvB,kBAAC,EAAD,KACE,kBAAC,GAAD,KACE,oCACE,kBAAC4Z,EAAA,EAAD,MACA,kBAAC,GAAD,CAAML,QAASA,SC5B3BM,IAASC,OACP,kBAAC,GAAD,MACA/e,SAASgf,eAAe,StByHpB,kBAAmB/gB,WACrBA,UAAUghB,cAAcngB,MACrBwD,MAAK,SAAA4c,GACJA,EAAaC,gBAEdzL,OAAM,SAAAxS,GACLD,QAAQC,MAAMA,EAAMc,c","file":"static/js/main.61782c66.chunk.js","sourcesContent":["\n\t\t\t\tvar addMethods = require(\"../../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = [\"load\",\"predict\"]\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"c274620fe1aaa38a8e0e.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React, { createContext, useState, useMemo, useCallback, useRef, useEffect, useContext } from 'react';\n\nexport const webcamContext = createContext();\n\nexport const useWebcam = () => {\n  const state = useContext(webcamContext);\n\n  if (!state) {\n    throw new Error('useWebcam must be used within a WebcamProvider');\n  }\n\n  return state;\n};\n\nconst VIDEO_WIDTH = 1280;\nconst VIDEO_HEIGHT = 720;\nconst AUTOSTART_KEY = 'AutoStartId';\nconst hasVideo = !!(navigator?.mediaDevices?.getUserMedia);\n\nconst WebcamProvider = ({children}) => {\n  const videoRef = useRef();\n  const canvasRef = useRef();\n  const [ctx, setCtx] = useState(null);\n  const [flipX, setFlipX] = useState(true);\n  const [ready, setReady] = useState(false);\n  const [cameras, setCameras] = useState([]);\n  const [scratchpad, setScratchpad] = useState(null);\n  const [videoError, setVideoError] = useState(null);\n  const [videoStream, setVideoStream] = useState(null);\n  const [currentDeviceId, setCurrentDeviceId] = useState(null);\n  const [autoStartDeviceId, _setAutoStartDeviceId] = useState(null);\n\n  useEffect(() => {\n    if (canvasRef.current && !ctx) {\n      setCtx(canvasRef.current.getContext('2d'));\n    } else if (ctx && !canvasRef.current) {\n      setCtx(null);\n    }\n  }, [ctx]);\n\n  // create a scratchpad for performing image transformations\n  // without cluttering the main canvas\n  useEffect(() => {\n    if (ready && !scratchpad) {\n      const canvas = document.createElement('canvas');\n      canvas.width = canvasRef.current.width;\n      canvas.height = canvasRef.current.height;\n      const _ctx = canvas.getContext('2d');\n\n      setScratchpad({ ctx: _ctx, canvas });\n    }\n  }, [scratchpad, ready]);\n\n  const clearScratchpad = useCallback(() => {\n    scratchpad.ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n  }, [scratchpad]);\n\n  const clearCanvas = useCallback(() => {\n    ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n  }, [ctx]);\n\n  const stopVideo = useCallback(() => {\n    if (videoStream) {\n      videoStream.getTracks().forEach(track => track.stop());\n    }\n\n    setVideoError(null);\n    setVideoStream(null);\n    setReady(false);\n    setCurrentDeviceId(null);\n  }, [videoStream])\n\n  const startVideo = useCallback(async (userConstraintsOrDeviceIdx) => {\n    stopVideo();\n\n    if (!hasVideo) {\n      const message = 'Video not supported';\n\n      console.error(message);\n      setVideoError(message);\n\n      return;\n    }\n\n    const isDeviceIdx = (typeof userConstraintsOrDeviceIdx === 'number');\n\n    const userConstraints = (isDeviceIdx ? {} : userConstraintsOrDeviceIdx || {});\n    const deviceIdx = (isDeviceIdx ? userConstraintsOrDeviceIdx : userConstraints.deviceIdx);\n\n    try {\n      console.log('Getting Webcam...');\n      const constraints = {\n        video: {\n          width: { exact: userConstraints.width || VIDEO_WIDTH }, \n          height: { exact: userConstraints.height || VIDEO_HEIGHT },\n        },\n        audio: false,\n      };\n\n      if (deviceIdx !== undefined) {\n        userConstraints.deviceId = cameras[deviceIdx]?.deviceId\n      }\n\n      if (userConstraints.deviceId) {\n        constraints.video.deviceId = { exact: userConstraints.deviceId }\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      const deviceId = stream.getTracks()[0]?.getCapabilities()?.deviceId\n\n      console.log('Got Webcam!');\n      setVideoStream(stream);\n      setCurrentDeviceId(deviceId);\n      videoRef.current.srcObject = stream;\n    } catch (e) {\n      const message = 'Error starting video.';\n      console.error(message);\n      console.error(e.message);\n      setVideoStream(null);\n      setReady(false);\n      setVideoError(message);\n\n      return;\n    }\n\n    return await Promise.all([\n      new Promise(resolve => {\n        videoRef.current.onloadedmetadata = () => resolve();\n      }),\n      new Promise(resolve => {\n        videoRef.current.onloadeddata = () => resolve();\n      }),\n    ]).then(() => setReady(true));\n  }, [stopVideo, videoRef, cameras]);\n\n  const discoverCameras = useCallback(async () => {\n    const enumerateDevices = navigator?.mediaDevices?.enumerateDevices;\n\n    if (!enumerateDevices) {\n      console.error('Cannot get cameras.');\n\n      return [];\n    }\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const foundCameras = devices.filter(({ kind, label }) => (\n      (kind === 'videoinput') && !label.includes('CamTwist')) // filter by video elements and remove CamTwist virtual devices\n    )\n      .map(currentCamera => {\n        let label;\n        const idx = currentCamera.label.lastIndexOf(' (');\n        if (idx > -1) label = currentCamera.label.slice(0, idx);\n\n        return (label ? ({ deviceId: currentCamera.deviceId, label }) : currentCamera);\n      });\n\n    setCameras(foundCameras);\n\n    return foundCameras;\n  }, []);\n\n  const toggleFlipX = useCallback(() => setFlipX(state => !state), []);\n\n  const setAutoStartDeviceId = useCallback((deviceId) => {\n    window.localStorage.setItem(AUTOSTART_KEY, deviceId);\n    _setAutoStartDeviceId(deviceId);\n  }, []);\n\n  const clearAutoStartDeviceId = useCallback(() => {\n    window.localStorage.removeItem(AUTOSTART_KEY);\n    _setAutoStartDeviceId(null);\n  }, []);\n\n  const imageDataToDataUri = useCallback((imageData) => {\n    clearScratchpad();\n    scratchpad.ctx.putImageData(imageData, 0, 0);\n    const dataUri = scratchpad.canvas.toDataURL('image/png');\n    clearScratchpad();\n\n    return dataUri;\n  }, [scratchpad, clearScratchpad]);\n\n  const dataUriToImageData = useCallback(async (dataUri) => {\n    clearScratchpad();\n    const img = new Image();\n    img.src = dataUri;\n\n    await new Promise((resolve) => {\n      img.onload = () => {\n        scratchpad.ctx.drawImage(img, 0, 0);\n        resolve();\n      };\n    });\n\n    const imageData = scratchpad.ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);\n    clearScratchpad();\n\n    return imageData;\n  }, [clearScratchpad, scratchpad]);\n\n  const getVideoAsImageData = useCallback(() => {\n    clearScratchpad();\n    scratchpad.ctx.drawImage(videoRef.current, 0, 0);\n    const imageData = scratchpad.ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);\n    clearScratchpad();\n\n    return imageData;\n  }, [clearScratchpad, scratchpad]);\n\n  useEffect(() => { \n    discoverCameras()\n      .then((foundCameras) => {\n        // TODO: if no autoStartId but there is a camera, use the first camera\n        const autoStartId = window.localStorage.getItem(AUTOSTART_KEY);\n        _setAutoStartDeviceId(autoStartId);\n        const foundCamera = !!(foundCameras.filter(({ deviceId }) => deviceId === autoStartId).length);\n\n        if (foundCamera) startVideo({ deviceId: autoStartId });\n      })\n  }, []); // eslint-disable-line\n\n  const context = useMemo(() => ({\n    ctx,\n    ready,\n    flipX,\n    cameras,\n    setFlipX,\n    videoRef,\n    hasVideo,\n    canvasRef,\n    stopVideo,\n    startVideo,\n    videoError,\n    scratchpad,\n    clearCanvas,\n    toggleFlipX,\n    videoStream,\n    currentDeviceId,\n    stop: stopVideo,\n    discoverCameras,\n    autoStartDeviceId,\n    start: startVideo,\n    imageDataToDataUri,\n    dataUriToImageData,\n    getVideoAsImageData,\n    setAutoStartDeviceId,\n    clearAutoStartDeviceId,\n  }), [\n    ctx,\n    ready,\n    flipX,\n    cameras,\n    setFlipX,\n    stopVideo,\n    startVideo,\n    videoError,\n    scratchpad,\n    toggleFlipX,\n    clearCanvas,\n    videoStream,\n    currentDeviceId,\n    discoverCameras,\n    autoStartDeviceId,\n    imageDataToDataUri,\n    dataUriToImageData,\n    getVideoAsImageData,\n    setAutoStartDeviceId,\n    clearAutoStartDeviceId,\n  ]);\n    \n  return (\n    <webcamContext.Provider value={context}>\n      {children}\n    </webcamContext.Provider>\n  )\n}\n\nexport default WebcamProvider;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/styles';\n\nimport { useWebcam } from '../context/webcam';\n\nconst useStyles = makeStyles((theme) => ({\n  root: (props) => ({\n    position: 'relative',\n  }),\n  video: (props) => ({\n    width: '100%',\n    height: '100%',\n    ...(props.flipX ? {\n      'p-webkit-transform': 'scaleX(- 1)',\n      transform: 'scaleX(-1)',\n    } : {}),\n  }),\n  canvas: (props) => ({\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n  }),\n}));\n\nconst Webcam = (props) => {\n  const webcam = useWebcam();\n  const classes = useStyles({ ...props, ...webcam });\n\n  return (\n    <div className={classes.root}>\n      <video\n        autoPlay={true}\n        ref={webcam.videoRef}\n        className={classes.video}\n        width={webcam.videoRef?.current?.videoWidth}\n        height={webcam.videoRef?.current?.videoHeight}\n      />\n      <canvas\n        ref={webcam.canvasRef}\n        className={classes.canvas}\n        width={webcam.videoRef?.current?.videoWidth}\n        height={webcam.videoRef?.current?.videoHeight}\n      />\n    </div>\n  )\n}\n\nWebcam.propTypes = {\n  styles: PropTypes.object,\n}\n\nexport default Webcam;\n","import PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/styles';\nimport React, { useCallback, useRef } from 'react';\n\nimport Button from '@material-ui/core/Button';\n\nconst useStyles = makeStyles((theme) => ({\n  fileInput: {\n    display: 'none',\n  }\n}));\n\nconst FileUpload = ({\n  onChange,\n  multiple,\n  children,\n  filter,\n  ...buttonProps\n}) => {\n  const classes = useStyles();\n\n  const fileRef = useRef();\n\n  const handleFileUpload = useCallback((fileObject) => {\n    if (!fileObject) return;\n\n    const disallowMultiple = (multiple === false);\n    const allFiles = (fileObject.target ? Array.from(fileObject.target.files) : fileObject.files);\n    let filteredFiles = (filter ? allFiles.filter(filter) : allFiles);\n\n    if (disallowMultiple && filteredFiles.length > 1) {\n      filteredFiles = filteredFiles.slice(0, 1);\n    }\n\n    onChange(filteredFiles);\n  }, [onChange, multiple, filter]);\n\n  const resetFile = useCallback(() => {\n    fileRef.current.value = null;\n  }, [fileRef]);\n\n  return (\n    <Button component=\"label\" {...buttonProps}>\n      {children}\n      <input\n        type=\"file\"\n        ref={fileRef}\n        className={classes.fileInput}\n        onClick={resetFile}\n        onChange={handleFileUpload}\n        multiple={(multiple !== false)}\n      />\n    </Button>\n  )\n}\n\nFileUpload.propTypes = {\n  multiple: PropTypes.bool,\n  filterFiles: PropTypes.func,\n  buttonProps: PropTypes.object,\n  onChange: PropTypes.func.isRequired,\n};\n\nexport default FileUpload;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport { makeStyles } from '@material-ui/core/styles';\n\nimport Select from '@material-ui/core/Select';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\n\nconst useStyles = makeStyles(theme => ({\n  formControl: {\n    minWidth: 120,\n  },\n  select: {\n    paddingTop: theme.spacing(1),\n    paddingBottom: theme.spacing(1),\n  },\n}));\n\nconst GameSelect = ({ value, ...props }) => {\n  const classes = useStyles();\n\n  return (\n    <FormControl className={classes.formControl}>\n      <Select classes={{ root: classes.select }} {...props} placeholder=\"Select Game\" value={value || ''} displayEmpty={true} variant=\"outlined\">\n        <MenuItem value=\"\">Select Masks</MenuItem>\n        {Array.from({ length: 3 }).map((_, idx) => (\n          <MenuItem key={idx} value={`set${idx + 1}.zip`}>Game {idx + 1}</MenuItem>\n        ))}\n      </Select>\n    </FormControl>\n  );\n};\n\nGameSelect.propTypes = {\n  value: PropTypes.string,\n  onChange: PropTypes.func.isRequired,\n  disabled: PropTypes.bool.isRequired,\n}\n\nexport default GameSelect;\n","import PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/styles';\nimport React, { useMemo, useCallback, useState } from 'react';\n\nimport Menu from '@material-ui/core/Menu';\nimport Button from '@material-ui/core/Button';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport Checkbox from '@material-ui/core/Checkbox';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport ArrowDropUpIcon from '@material-ui/icons/ArrowDropUp';\nimport ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';\n\nconst noop = () => {};\n\nconst useStyles = makeStyles((theme) => ({\n  root: (props) => ({\n    position: 'relative',\n  }),\n  arrowIcon: (props) => ({\n    marginLeft: theme.spacing(1),\n  }),\n  tooltip: (props) => ({\n    position: 'relative',\n    margin: 0,\n  }),\n  arrow: (props) => ({\n    position: 'absolute',\n    fontSize: 6,\n    '&::before': {\n      content: '\"\"',\n      margin: 'auto',\n      display: 'block',\n      width: 0,\n      height: 0,\n      borderStyle: 'solid',\n    },\n  }),\n  paper: {\n    border: '1px solid #d3d4d5',\n  },\n  popper: (props) => ({\n    '&[x-placement*=\"bottom\"] $arrow': {\n      top: 0,\n      left: 0,\n      marginTop: '-0.95em',\n      width: '2em',\n      height: '1em',\n      '&::before': {\n        borderWidth: '0 1em 1em 1em',\n        borderColor: `transparent transparent ${theme.palette.grey[700]} transparent`,\n      },\n    },\n    '&[x-placement*=\"top\"] $arrow': {\n      bottom: 0,\n      left: 0,\n      marginBottom: '-0.95em',\n      width: '2em',\n      height: '1em',\n      '&::before': {\n        borderWidth: '1em 1em 0 1em',\n        borderColor: `${theme.palette.grey[700]} transparent transparent transparent`,\n      },\n    },\n    '&[x-placement*=\"right\"] $arrow': {\n      left: 0,\n      marginLeft: '-0.95em',\n      height: '2em',\n      width: '1em',\n      '&::before': {\n        borderWidth: '1em 1em 1em 0',\n        borderColor: `transparent ${theme.palette.grey[700]} transparent transparent`,\n      },\n    },\n    '&[x-placement*=\"left\"] $arrow': {\n      right: 0,\n      marginRight: '-0.95em',\n      height: '2em',\n      width: '1em',\n      '&::before': {\n        borderWidth: '1em 0 1em 1em',\n        borderColor: `transparent transparent transparent ${theme.palette.grey[700]}`,\n      },\n    },\n  }),\n}))\n\nconst SelectAndCheck = (props) => {\n  const classes = useStyles(props);\n  const id = useMemo(Math.random, []);\n\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [arrowRef, setArrowRef] = useState(null);\n\n  const handleClickSelect = useCallback((event) => {\n    setAnchorEl(event.currentTarget);\n  }, []);\n\n  const closeSelect = useCallback(() => { setAnchorEl(null) }, []);\n\n  const handleCloseSelect = useCallback(async () => {\n    const keepOpen = await ((props.onClose || noop)());\n    \n    if (keepOpen !== true) {\n      closeSelect();\n    }\n  }, [closeSelect, props.onClose]);\n\n  const handleClickCheckbox = useCallback((event) => {\n    (props.onClickCheckbox || noop)(event.target.value, handleCloseSelect);\n  }, [props.onClickCheckbox, handleCloseSelect]);\n\n  const handleClickSelectItem = useCallback((value) => async (event) => {\n    if (event.target.type === 'checkbox') {\n      return;\n    }\n\n    const keepOpen = await ((props.onSelect || noop)(value));\n\n    if (keepOpen !== true) {\n      handleCloseSelect();\n    }\n  }, [handleCloseSelect, props.onSelect]);\n\n  const open = (!!anchorEl);\n\n  return (\n    <div className={classes.root}>\n      <Button\n        disableRipple\n        variant=\"outlined\"\n        aria-haspopup=\"true\"\n        className={classes.button}\n        onClick={handleClickSelect}\n        aria-controls={`select-and-check-${id}`}\n        { ...props.SelectProps }\n      >\n        { open ? (props.activeTitle || props.title) : props.title }\n        { open\n          ? <ArrowDropUpIcon className={classes.arrowIcon} /> \n          : <ArrowDropDownIcon className={classes.arrowIcon} />\n        }\n      </Button>\n      <Menu\n        keepMounted\n        open={open}\n        elevation={0}\n        anchorEl={anchorEl}\n        getContentAnchorEl={null}\n        onClose={handleCloseSelect}\n        id={`select-and-check-${id}`}\n        classes={{ paper: classes.paper }}\n        anchorOrigin={{vertical: 'bottom', horizontal: 'center'}}\n        transformOrigin={{vertical: 'top', horizontal: 'center'}}\n        { ...props.MenuProps }    \n      >\n        {props.options?.map(({ key, value, text, selected, tooltipTitle, checked, checkboxValue }, i) => {\n          let TooltipAndCheckbox = null;\n\n          if (typeof checked === 'boolean') {\n            const _Checkbox = <Checkbox checked={checked} onClick={handleClickCheckbox} value={checkboxValue === undefined ? value : checkboxValue} />\n            const tooltipText = (tooltipTitle || props.tooltipTitle);\n\n            TooltipAndCheckbox = tooltipText ? (\n              <Tooltip\n                classes={{ tooltip: classes.tooltip, popper: classes.popper }}\n                PopperProps={{\n                  popperOptions: {\n                    modifiers: {\n                      arrow: {\n                        enabled: !!arrowRef,\n                        element: arrowRef,\n                      },\n                    },\n                  },\n                }}\n                title={\n                  <React.Fragment>\n                    {tooltipText}\n                    <span className={classes.arrow} ref={setArrowRef} />\n                  </React.Fragment>\n                }\n                enterDelay={props.tooltipEnterDelay === undefined ? 750 : props.tooltipEnterDelay}\n                leaveDelay={props.tooltipLeaveDelay || 0}\n                aria-label=\"checkbox\"\n                placement={props.tooltipPlacement || \"top\"}\n              >\n                {_Checkbox}\n              </Tooltip>\n            ) : _Checkbox\n          }\n\n          return (\n            <MenuItem \n              key={key || i}\n              onClick={handleClickSelectItem(value)}\n              selected={selected}\n              {...props.MenuItemProps}\n            >\n              {TooltipAndCheckbox}\n              <ListItemText primary={text || value?.toString()} />\n            </MenuItem>\n          )}\n        )}\n      </Menu>\n    </div>\n  )\n}\n\nSelectAndCheck.propTypes = {\n  styles: PropTypes.object,\n  onClose: PropTypes.func,\n  title: PropTypes.string,\n  onSelect: PropTypes.func,\n  MenuProps: PropTypes.object,\n  SelectProps: PropTypes.object,\n  activeTitle: PropTypes.string,\n  tooltipTitle: PropTypes.string,\n  MenuItemProps: PropTypes.object,\n  onClickCheckbox: PropTypes.func,\n  tooltipEnterDelay: PropTypes.number,\n  tooltipLeaveDelay: PropTypes.number,\n  tooltipPlacement: PropTypes.string,\n  options: PropTypes.arrayOf(PropTypes.object).isRequired,\n}\n\nexport default SelectAndCheck\n","import PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/styles';\nimport React, { useMemo, useCallback } from 'react';\n\nimport SelectAndCheck from './SelectAndCheck';\nimport { useWebcam } from '../context/webcam';\n\nconst useStyles = makeStyles((theme) => ({\n  root: (props) => ({\n  }),\n}));\n\nconst WebcamSelect = (props) => {\n  const webcam = useWebcam();\n  const classes = useStyles({ ...props, ...webcam });\n\n  const selectedCamera = useMemo(() => {\n    let _selectedCamera = { deviceId: null, label: null, none: true };\n\n    if (!webcam.currentDeviceId) {\n      return _selectedCamera;\n    }\n\n    webcam.cameras.some((camera) => {\n      if (camera.deviceId === webcam.currentDeviceId) {\n        _selectedCamera = camera;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    return _selectedCamera;\n  }, [webcam.cameras, webcam.currentDeviceId]);\n\n  const handleSelectCamera = useCallback((deviceId) => {\n    if (webcam.currentDeviceId !== deviceId) {\n      webcam.start({ deviceId });\n    }\n  }, [webcam]);\n\n  const handleSetDefaultCamera = useCallback((deviceId) => {\n    if (webcam.autoStartDeviceId === deviceId) {\n      webcam.clearAutoStartDeviceId();\n    } else {\n      webcam.setAutoStartDeviceId(deviceId);\n      handleSelectCamera(deviceId);\n    }\n  }, [webcam, handleSelectCamera]);\n\n  return (\n    <div className={classes.root}>\n      <SelectAndCheck\n        activeTitle=\"Select Camera\"\n        title={webcam.cameras?.length\n          ? selectedCamera.label || 'No Camera Selected'\n          : 'No Cameras Detected'\n        }\n        onSelect={handleSelectCamera}\n        onClickCheckbox={handleSetDefaultCamera}\n        options={webcam.cameras.map(camera => ({\n          key: camera.label,\n          value: camera.deviceId,\n          text: camera.label || 'Unknown Device',\n          selected: camera.deviceId === webcam.currentDeviceId,\n          checked: (webcam.autoStartDeviceId === camera.deviceId),\n          tooltipTitle: (webcam.autoStartDeviceId === camera.deviceId \n            ? 'Remove Default' \n            : 'Set Default'),\n        }))}\n      />\n    </div>\n  )\n};\n\nWebcamSelect.propTypes = {\n  styles: PropTypes.object,\n};\n\nexport default WebcamSelect;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/core';\n\nimport Paper from '@material-ui/core/Paper';\nimport Typography from '@material-ui/core/Typography';\n\nconst useStyles = makeStyles(theme => ({\n  masks: {\n    padding: theme.spacing(1),\n  },\n  masksHeader: {\n  },\n  masksList: {\n    display: 'flex',\n    flexFlow: 'row wrap',\n    justifyContent: 'space-around',\n  },\n  imgContainer: {\n    width: 200,\n    padding: theme.spacing(0.5),\n    marginTop: theme.spacing(0.5),\n    textAlign: 'right',\n  },\n  img: {\n    background: 'black',\n    width: '100%',\n  },\n}));\n\nconst ScoreResults = (props) => {\n  const classes = useStyles();\n\n  const { results } = props;\n\n  return (!!results.length && (\n    <>\n      <Paper className={classes.masks}>\n        <div className={classes.masksHeader}>\n          <Typography variant=\"h6\" component=\"h3\">\n            Results\n          </Typography>\n          <Typography component=\"p\">\n            Average: {results.reduce((acc, {score}) => (acc + score), 0) / results.length}\n          </Typography>\n        </div>\n        <ul className={classes.masksList}>\n          {results.map(({ score, dataUri }, i) => (\n            <li className={classes.imgContainer} key={dataUri}>\n              <Typography>{score}</Typography>\n              <img src={dataUri} className={classes.img} alt={`mask #${i}`} />\n            </li>\n          ))}\n        </ul>\n      </Paper>\n    </>\n  ));\n};\n\nScoreResults.propTypes = {\n  results: PropTypes.array.isRequired,\n}\n\nexport default ScoreResults;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/core';\n\nimport Paper from '@material-ui/core/Paper';\nimport Button from '@material-ui/core/Button';\nimport IconButton from '@material-ui/core/IconButton';\nimport Typography from '@material-ui/core/Typography';\nimport DeleteForeverIcon from '@material-ui/icons/DeleteForever';\n\nconst useStyles = makeStyles(theme => ({\n  masks: {\n    padding: theme.spacing(1),\n  },\n  masksHeader: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: theme.spacing(1),\n  },\n  masksList: {\n    display: 'flex',\n    flexFlow: 'row wrap',\n    justifyContent: 'space-around',\n  },\n  imgContainer: {\n    width: 200,\n    background: 'black',\n    padding: theme.spacing(0.5),\n    marginTop: theme.spacing(0.5),\n    position: 'relative',\n    '&:hover': {\n      '& > div': {\n        background: 'rgba(255,0,0,0.65)',\n      }\n    }\n  },\n  img: {\n    width: '100%',\n    background: 'rgba(0,0,0,0)',\n  },\n  removeMask: {\n    display: 'flex',\n    transition: 'all 100ms',\n    position: 'absolute',\n    top: 0,\n    bottom: 0,\n    width: '100%',\n    left: 0,\n    justifyContent: 'center',\n    alignItems: 'center',\n    '&:hover': {\n      '& > button': {\n        display: 'inherit',\n      }\n    }\n  },\n  iconBtn: {\n    display: 'none',\n    color: 'black',\n    backgroundColor: 'rgba(255,255,255,0.5)',\n    '&:hover': {\n      backgroundColor: 'rgba(255,255,255,0.75)',\n    },\n    '&:active, &:focused': {\n      backgroundColor: 'rgba(255,255,255,0.9)',\n    },\n  },\n}));\n\nconst CapturedMasks = (props) => {\n  const classes = useStyles();\n\n  const { captureMasks } = props;\n\n  return (!!captureMasks.masks.length && (\n    <>\n      <Paper className={classes.masks}>\n        <div className={classes.masksHeader}>\n          <Typography variant=\"h6\" component=\"h3\">\n            Candidate Masks\n          </Typography>\n          <div>\n            <Button onClick={captureMasks.downloadMasks}>\n              Download\n            </Button>\n            <Button onClick={captureMasks.removeAllMasks}>\n              Clear All\n            </Button>\n          </div>\n        </div>\n        <ul className={classes.masksList}>\n          {captureMasks.masks.map(({binary:dataUri}, i) => (\n            <li className={classes.imgContainer} key={dataUri}>\n              <div className={classes.removeMask}>\n                <IconButton\n                  name={i}\n                  className={classes.iconBtn}\n                  onClick={captureMasks.removeMask}\n                >\n                  <DeleteForeverIcon fontSize=\"large\" />\n                </IconButton>\n              </div>\n              <img src={dataUri} className={classes.img} alt={`mask #${i}`} />\n            </li>\n          ))}\n        </ul>\n      </Paper>\n    </>\n  ));\n};\n\nCapturedMasks.propTypes = {\n  captureMasks: PropTypes.object.isRequired,\n}\n\nexport default CapturedMasks;\n","import { useState, useEffect, useCallback } from \"react\";\n\nconst synth = window.speechSynthesis;\n\nexport const useSpeech = () => {\n  const [voices, setVoices] = useState(null);\n  const [voice, setVoice] = useState(null);\n\n  useEffect(() => {\n    if (!voices) {\n      const allVoices = synth.getVoices();\n      setVoices(allVoices);\n      setVoice(allVoices[0]);\n    }\n  }, [voices]);\n\n  const say = useCallback((text) => {\n    const utterance = new SpeechSynthesisUtterance(text);\n    utterance.voice = voice;\n    synth.speak(utterance);\n  }, [voice]);\n\n  const countdown = useCallback((from, { onEnd, onEach }={}) => {\n    if (onEnd) setTimeout(onEnd, from * 1000);\n    Array.from({ length: from })\n      .forEach((_, idx) => {\n        const num = from - idx;\n        setTimeout(() => {\n          say(num);\n          if (onEach) onEach(num);\n        }, idx * 1000);\n      })\n  }, [say]);\n\n  return { say, countdown };\n};\n","import { useCallback, useRef, useMemo } from 'react';\n\nimport { useSpeech } from \"./speech\";\n\nexport const useLapTimer = () => {\n  const lapTimer = useRef();\n  const speech = useSpeech();\n\n  const useTimer = useCallback(({\n    onBeforeStartLap,\n    onLap,\n    onEnd,\n    maxLaps,\n    lapDuration = 3000,\n    postLapDelay = 1000,\n    printSeconds = true,\n    announceSeconds = true,\n  } = {}) => {\n    if (onLap && !lapTimer.current) {\n      lapTimer.current = {\n        onBeforeStartLap,\n        onBeforeComplete: false,\n        onBeforeStarted: false,\n        onLap,\n        onEnd,\n        maxLaps,\n        numLaps: 0,\n        lapDuration,\n        postLapDelay,\n        printSeconds,\n        announceSeconds,\n      };\n    }\n  }, []);\n\n  const handleLap = useCallback(async ({ time, webcam, predict, stop }) => {\n    // handleLoop called useTimer\n    if (lapTimer.current) {\n      // if they've provided an initialization function,\n      // run it and don't start the first lap until it resolves\n      if (lapTimer.current.onBeforeStartLap && !lapTimer.current.onBeforeComplete) {\n        if (lapTimer.current.onBeforeStarted) return;\n        else {\n          lapTimer.current.onBeforeStarted = true;\n\n          await lapTimer.current.onBeforeStartLap({ time, webcam, predict, stop });\n          lapTimer.current.onBeforeComplete = true;\n          time.resetLapTime();\n          return;\n        }\n      }\n\n      if (lapTimer.current.maxLaps && (lapTimer.current.numLaps === lapTimer.current.maxLaps)) {\n        if (lapTimer.current.onEnd) {\n          await lapTimer.current.onEnd({ time, webcam, predict, stop });\n        }\n\n        lapTimer.current = null;\n        return stop();\n      }\n\n      const secondsPassed = Math.floor(time.lapTime / 1000);\n\n      // we get a single instance of -1 so set min to 0\n      const countdown = Math.max((lapTimer.current.lapDuration / 1000) - secondsPassed, 0);\n\n      // display the integer seconds remaining in the lap in the top left corner of the canvas\n      if (lapTimer.current.printSeconds) {\n        const { ctx } = webcam;\n        ctx.font = '40px Arial';\n        ctx.fillStyle = 'white';\n        ctx.clearRect(0, 0, 50, 50);\n\n        if (countdown) { // don't print if 0\n          ctx.fillText(countdown, 10, 40);\n        }\n      }\n\n      // announce the current countdown time (if not announced yet and requested)\n      if (countdown && lapTimer.current.announceSeconds && lapTimer.current.lastSpeech !== countdown) {\n        lapTimer.current.lastSpeech = countdown;\n        speech.say(`${countdown}`);\n      }\n\n      // Once we've reached the end of the lap\n      // fire the provided onLap handler and set handlerCalled so we don't call it again until next lap\n      if (time.lapTime >= lapTimer.current.lapDuration && !lapTimer.current.handlerCalled) {\n        lapTimer.current.numLaps++;\n        lapTimer.current.handlerCalled = true;\n        lapTimer.current.handlerResolved = false;\n        await lapTimer.current.onLap({ time, webcam, predict, stop, lapNum: lapTimer.current.numLaps });\n        lapTimer.current.handlerResolved = true;\n      } else if (time.lapTime >= (lapTimer.current.lapDuration + lapTimer.current.postLapDelay) && lapTimer.current.handlerResolved) {\n        // we've already called the lap handler \n        // and the handler has resolved\n        // and delayed an additional amount of time\n        // so we reset the lapTime and mark the handler as ready to be called again\n        time.resetLapTime();\n        lapTimer.current.handlerCalled = false;\n        lapTimer.current.handlerResolved = false;\n      }\n    }\n  }, [speech]);\n\n  const clear = useCallback(() => {\n    lapTimer.current = null;\n  }, []);\n\n  return useMemo(() => ({\n    clear,\n    useTimer,\n    handleLap,\n  }), [\n    clear,\n    useTimer,\n    handleLap,\n  ]);\n};\n","import { useRef, useState, useEffect, useCallback } from \"react\";\n\nimport { useWebcam } from \"../context/webcam\";\n\n// eslint-disable-next-line import/no-webpack-loader-syntax\nimport BodyPixWorker from 'workerize-loader!../worker/bodyPix';\n\nconst bodyPixWorker = BodyPixWorker();\n\nexport const useBodyPixController = () => {\n  const webcam = useWebcam();\n\n  const loadRef = useRef();\n  const preloadRef = useRef();\n  const [netReady, setNetReady] = useState(false);\n  const [netPreloaded, setNetPreloaded] = useState(false);\n\n  // load the model on the first mount\n  useEffect(() => {\n    if (!loadRef.current && webcam.ready) {\n      loadRef.current = true;\n      bodyPixWorker.load()\n        .then(() => {\n          console.log('BodyPix loaded');\n          setNetReady(true);\n        })\n        .catch(console.error);\n    }\n  }, [webcam]);\n\n  // TODO: Make it possible to tweak bodyPix settings\n  const predict = useCallback(async () => {\n    if (!netReady) {\n      throw new Error('Please wait for the model to load before calling \"predict\"');\n    }\n\n    const segmentation = await bodyPixWorker.predict(webcam.getVideoAsImageData());\n\n    // console.log({segmentation});\n    \n    return segmentation;\n  }, [netReady, webcam]);\n\n  // pre load the model by running a first prediction\n  useEffect(() => {\n    if (netReady && !preloadRef.current && !netPreloaded) {\n      preloadRef.current = true;\n      predict()\n        .then(() => {\n          setNetPreloaded(true);\n        });\n    }\n  }, [predict, netReady, netPreloaded]);\n\n  // don't return the prediction fn until the model has processed the first frame\n  return netPreloaded ? predict : null;\n};\n","import React, { useContext, createContext } from 'react';\n\nimport { useBodyPixController } from '../hooks/bodyPixController';\n\nexport const bodyPixContext = createContext();\n\nexport const useBodyPix = () => {\n  const state = useContext(bodyPixContext);\n\n  // specifically check for undefined, not just truthy\n  // bc bodyPixController returns null before it is ready\n  if (state === undefined) {\n    throw new Error('useBodyPix must be used within a BodyPixProvider');\n  }\n\n  return state;\n};\n\nconst BodyPixProvider = ({children}) => {\n  const context = useBodyPixController();\n\n  return (\n    <bodyPixContext.Provider value={context}>\n      {children}\n    </bodyPixContext.Provider>\n  )\n}\n\nexport default BodyPixProvider;\n","import { useRef, useState, useCallback, useMemo } from \"react\";\n\nimport { useLoopTime } from \"./loopTime\";\nimport { useLapTimer } from \"./lapTimer\";\nimport { useWebcam } from \"../context/webcam\";\nimport { useBodyPix } from \"../context/bodyPix\";\n\nexport const useLoop = (handleLoop) => {\n  const webcam = useWebcam();\n  const predict = useBodyPix();\n  \n  const loopTime = useLoopTime();\n  const lapTimer = useLapTimer();\n\n  const loopingRef = useRef();\n  const handleLoopRef = useRef();\n  const [looping, setLooping] = useState(false);\n\n  // set the flags to start the loop\n  const setStartLoop = useCallback(() => {\n    // we clear the lapTimer here as opposed to after \"stopping\" the loop to avoid async errors\n    lapTimer.clear();\n    loopTime.reset();\n    loopingRef.current = true;\n    setLooping(true);\n  }, [loopTime, lapTimer]);\n  \n  // clear loop flags to trigger end of loop\n  // not synchronous, loop will terminate on next pass\n  const setStopLoop = useCallback(() => {\n    loopingRef.current = false;\n    setLooping(false);\n  }, []);\n\n  // fn passed to requestAnimationFrame\n  // keeps time and runs handleLoop fn passed to start\n  const loop = useCallback(async (timestamp) => {\n    const time = loopTime.update(timestamp);\n    const cleanup = await handleLoopRef.current({\n      time,\n      webcam,\n      predict,\n      useTimer: lapTimer.useTimer,\n      stop: setStopLoop,\n    });\n\n    lapTimer.handleLap({\n      time,\n      webcam,\n      predict,\n      stop: setStopLoop,\n    });\n\n    if (loopingRef.current) {\n      requestAnimationFrame(loop);\n    } else{\n      setStopLoop();\n      handleLoopRef.current = null;\n      webcam.clearCanvas();\n      if (cleanup) cleanup();\n    }\n  }, [\n    webcam,\n    predict,\n    lapTimer,\n    loopTime,\n    setStopLoop,\n  ]);\n\n  const start = useCallback(async (handleLoop) => {\n    if (loopingRef.current) {\n      throw new Error('The loop is already running');\n    } else if (!predict) {\n      throw new Error('Please wait for BodyPix to load...');\n    } else if (!handleLoop) {\n      throw new Error('A loop handler is required when calling loop.start');\n    }\n\n    handleLoopRef.current = handleLoop;\n    setStartLoop();\n\n    return requestAnimationFrame(loop);\n  }, [loop, predict, setStartLoop]);\n\n  const controller = useMemo(() => ({\n    start,\n    looping,\n    stop: setStopLoop,\n    ready: predict && webcam.ready,\n  }), [\n    start,\n    predict,\n    looping,\n    setStopLoop,\n    webcam.ready,\n  ]);\n\n  return controller;\n};\n","import { useCallback, useRef, useMemo } from \"react\";\n\nexport const useLoopTime = () => {\n  const lastTimeRef = useRef();\n  const startTimeRef = useRef();\n  const totalFramesRef = useRef();\n  const fpsSumRef = useRef();\n  const lapTime = useRef();\n\n  const reset = useCallback((timestamp=0) => {\n    startTimeRef.current = timestamp;\n    lastTimeRef.current = timestamp;\n    fpsSumRef.current = 0;\n    totalFramesRef.current = 0;\n    lapTime.current = 0;\n  }, []);\n\n  const resetLapTime = useCallback(() => {\n    lapTime.current = 0;\n  }, []);\n  \n  const update = useCallback((timestamp) => {\n    let first = false;\n    if (!startTimeRef.current) {\n      first = true;\n      reset(timestamp);\n    }\n\n    const deltaTime = timestamp - lastTimeRef.current;\n    lapTime.current += deltaTime;\n\n    let fps = 0;\n    let avgFps = 0;\n\n    // start calculating after the first loop to avoid dividing by 0\n    if (totalFramesRef.current++) {\n      fps = 1000 / deltaTime;\n      avgFps = fpsSumRef.current / totalFramesRef.current;\n      fpsSumRef.current += fps;\n    }\n    \n    const elapsed = timestamp - startTimeRef.current;\n    lastTimeRef.current = timestamp;\n\n    return {\n      first,\n      timestamp,\n      fps,\n      avgFps,\n      elapsed,\n      frames: totalFramesRef.current,\n      lapTime: lapTime.current,\n      resetLapTime,\n    };\n  }, [reset, resetLapTime]);\n\n  const controller = useMemo(() => ({ update, reset }), [update, reset]);\n\n  return controller;\n};\n","/* global cv:false */\nimport inside from 'point-in-polygon';\n\nexport const polygonToArray = (polygon, width, height) => {\n    const bytes = new Uint8ClampedArray(width * height * 4);\n    for (let i = 0; i < height * width; ++i) {\n      const x = i % width;\n      const y = parseInt(i / width);\n      const isIn = Number(inside([x, y], polygon)) * 255;\n      bytes[i*4] = isIn;\n      bytes[i*4+1] = isIn;\n      bytes[i*4+2] = isIn;\n      bytes[i*4+3] = isIn ? 128 : 0;\n    }\n    return new ImageData(bytes, width, height);\n}\n\nexport const getSegmentationeOverlayAndBinaryImageData = (segmentation, flipped) => {\n  const {data, width, height} = segmentation;\n  const binaryBytes = new Uint8ClampedArray(segmentation.data.length * 4);\n  // TODO: See if we can directly create CVMat from segmentation.data.\n\n  for (let i = 0; i < height * width; ++i) {\n    const x = i % width;\n    const y = parseInt(i / width);\n\n    const isPerson = data[i];\n    const bytes_index  = (flipped ? (width - x) + (width * y) : i);\n\n    binaryBytes[bytes_index*4] = isPerson ? 255 : 0;  // red\n    binaryBytes[bytes_index*4+1] = isPerson ? 255 : 0;  // green\n    binaryBytes[bytes_index*4+2] = isPerson ? 255 : 0;  // blue\n    binaryBytes[bytes_index*4+3] = isPerson ? 255 : 0;  // alpha\n  }\n  let binaryImageData = new ImageData(binaryBytes, width, height);\n\n  // Load data into Mat.\n  let segData = cv.matFromImageData(binaryImageData);\n\n  // Create a single channel mask.\n  let rgbaPlanes = new cv.MatVector();\n  cv.split(segData, rgbaPlanes);\n  let pre_mask = new cv.Mat();\n  // Threshold on one channel (doesn't matter which one)\n  cv.threshold(rgbaPlanes.get(0), pre_mask, 128, 1, cv.THRESH_BINARY); // Mask is 0s and 1s, type CV_8UC1\n\n  // Use findContours/drawContours to remove small blobs.\n  // See example: https://docs.opencv.org/3.4/d5/daa/tutorial_js_contours_begin.html\n  // TODO: This only updates the overlay. Also update the Mask.\n  let contours = new cv.MatVector();\n  let hierarchy = new cv.Mat();\n  cv.findContours(pre_mask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);\n  let mask = cv.Mat.zeros(pre_mask.rows, pre_mask.cols, cv.CV_8UC1);\n  let area = 0;\n  let minAreaThreshold = 10000;  // Can change this, starting off with 100x100.\n  for (let i = 0; i < contours.size(); ++i) {\n    area = cv.contourArea(contours.get(i));\n    if (area > minAreaThreshold) {\n      cv.drawContours(mask, contours, i, [1, 1, 1, 1], -1/*fill*/, cv.LINE_8, hierarchy, 100);\n    }\n  }\n\n  // Create a Blue opaque overlay with a solid Green border.\n  // NOTE: Images are in RGBA format\n  let overlay = cv.Mat.zeros(segData.rows, segData.cols, cv.CV_8UC4);\n  cv.split(overlay, rgbaPlanes);\n  // Fill blue channel and alpha using the mask.\n  rgbaPlanes.get(2).setTo([255, 0, 0, 0], mask);  // Blue\n  rgbaPlanes.get(3).setTo([128, 0, 0, 0], mask);  // Alpha\n  // Get a border mask.\n  let borderSize = 10;\n  let borderMask = new cv.Mat();\n  let M = cv.Mat.ones(borderSize, borderSize, cv.CV_8U);\n  let anchor = new cv.Point(-1, -1);\n  cv.dilate(mask, borderMask, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());\n  cv.subtract(borderMask, mask, borderMask);\n  // Fill solid green using the border mask.\n  rgbaPlanes.get(1).setTo([255, 0, 0, 0], borderMask);  // Green\n  rgbaPlanes.get(3).setTo([255, 0, 0, 0], borderMask);  // Alpha\n  // Merge into final result.\n  cv.merge(rgbaPlanes, overlay);\n  const overlayImageData = new ImageData(new Uint8ClampedArray(overlay.data), overlay.cols, overlay.rows);\n  // Delete Mat objects.\n  segData.delete(); rgbaPlanes.delete(); mask.delete(); overlay.delete(); M.delete();\n\n  // TODO: only return one image here.\n  return {overlayImageData, binaryImageData: overlayImageData};\n}\n\nexport const getScoreAndOverlayForSegmentationAndImageData = (targetImageData, segmentation, flipped) => {\n  const {data, width, height} = segmentation;\n  const bytes = new Uint8ClampedArray(segmentation.data.length * 4);\n\n  let union = 0;\n  let intersection = 0;\n\n  for (let i = 0; i < height * width; ++i) {\n    const x = i % width;\n    const y = parseInt(i / width);\n\n    const bytes_index  = (flipped ? (width - x) + (width * y) : i);\n\n    const isPerson = data[i];\n    const isInPolygon = !!targetImageData.data[bytes_index*4+2];\n    const isIntersection = isInPolygon && isPerson;\n    const isMissedPolygon = isInPolygon && !isPerson;\n    const isPersonOutOfPolygon = !isInPolygon && isPerson;\n    const isInteresting = (isPersonOutOfPolygon || isIntersection || isMissedPolygon);\n\n    if (isIntersection) intersection++;\n    if (isPerson || isInPolygon) union++;\n    \n    bytes[bytes_index*4] = isPersonOutOfPolygon ? 255 : 0;  // red\n    bytes[bytes_index*4+1] = isIntersection? 255 : 0;   // green\n    bytes[bytes_index*4+2] = isMissedPolygon ? 255 : 0; // blue\n    bytes[bytes_index*4+3] = isInteresting ? 128 : 0; // alpha\n  }\n\n  const score = Math.round(intersection / (union+0.0000001) * 100);\n  const overlay = new ImageData(bytes, width, height);\n\n  return { score, overlay };\n}\n\nexport const drawPolygon = (ctx, polygon, color='rgba(255, 255, 255, 0.5)') => {\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(polygon[0][0], polygon[0][1]);\n  const vertices = polygon.slice(1);\n  vertices.forEach(([x, y]) => {\n    ctx.lineTo(x, y);\n  });\n  ctx.closePath();\n  ctx.fill();\n};\n\nexport const flipPolygon = (polygon, width) => polygon.map(([x, y]) => [width - x, y]);\n\nexport const inflatePolygon = (width, height) => polygon => polygon.map(([x, y]) => [x*width, y*height]);\n\nexport const saveAs = (blob, filename) => {\n  if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {\n    return navigator.msSaveOrOpenBlob(blob, filename);\n  } else if (typeof navigator.msSaveBlob !== 'undefined') {\n    return navigator.msSaveBlob(blob, filename);\n  } else {\n    var elem = window.document.createElement('a');\n    elem.href = window.URL.createObjectURL(blob);\n    elem.download = filename;\n    elem.style = 'display:none;opacity:0;color:transparent;';\n    (document.body || document.documentElement).appendChild(elem);\n    if (typeof elem.click === 'function') {\n      elem.click();\n    } else {\n      elem.target = '_blank';\n      elem.dispatchEvent(new MouseEvent('click', {\n        view: window,\n        bubbles: true,\n        cancelable: true\n      }));\n    }\n    URL.revokeObjectURL(elem.href);\n  }\n}\n","import JSZip from \"jszip\";\nimport JSZipUtils from 'jszip-utils';\nimport { useMemo, useRef, useCallback, useState } from \"react\";\n\nimport { useIterateMask } from \"../iterateMask\";\nimport { useWebcam } from \"../../context/webcam\";\nimport { getScoreAndOverlayForSegmentationAndImageData } from \"../../lib/util\";\n\nexport const useSimpleGame = () => {\n  const promRef = useRef();\n  const webcam = useWebcam();\n  const [loading, setLoading] = useState(false);\n\n  const maskIterator = useIterateMask();\n  const [scores, setScores] = useState([]);\n  const [selectedMasks, setSelectedMasks] = useState(null);\n\n\n  const handleZip = useCallback(async (file) => {\n    setLoading(true);\n    const data = await JSZip.loadAsync(file);\n      const binaryMasks = await Promise.all(data\n        .filter((name) => name.endsWith('.png'))\n        .map(({ name }) => data.file(name).async('base64'))\n      );\n\n      const masksAsImageData = await Promise.all(binaryMasks\n        .map(b64 => webcam.dataUriToImageData(`data:image/png;base64,${b64}`))\n      );\n\n      maskIterator.setMasks(masksAsImageData);\n      setLoading(false);\n  }, [maskIterator, webcam]);\n\n  const handleLoadUserMasks = useCallback(([file]) => {\n    if (file.type !== 'application/zip') {\n      console.error('Expected a zip file but got', file.type);\n      return;\n    }\n\n    handleZip(file);\n    setSelectedMasks(null);\n  }, [handleZip]);\n\n  const handleLoadShippedMasks = useCallback(async ({ target: { value: filename }}) => {\n    if (!filename) {\n      setSelectedMasks(null);\n      return;\n    }\n\n    const file = await new JSZip.external.Promise((resolve, reject) => {\n      JSZipUtils.getBinaryContent(process.env.PUBLIC_URL + `/masks/${filename}`, (err, data) => {\n          if (err) reject(err);\n          else resolve(data);\n      });\n    });\n\n  handleZip(file);\n  setSelectedMasks(filename);\n  }, [handleZip]);\n\n  const handleLoop = useCallback(async (controller) => {\n    if (controller.time.first) {\n      maskIterator.next(); // load the first mask\n      setScores([]); // clear the scores\n      controller.useTimer({\n        maxLaps: maskIterator.numMasks,\n        printSeconds: true,\n        announceSeconds: true,\n        lapDuration: 3000,\n        newLapDelay: 1000,\n        onLap: ({ predict, time, stop }) => {\n          const target = maskIterator.maskRef.current;\n\n          // we actually shouldn't reach this,\n          // because the maxLaps should trigger a stop first\n          if (!target) return stop();\n\n          promRef.current = predict(webcam.videoRef.current)\n            .then(async segmentation => {\n              const { score, overlay } = getScoreAndOverlayForSegmentationAndImageData(target, segmentation, webcam.flipX);\n\n              const dataUri = webcam.imageDataToDataUri(overlay);\n              setScores(state => [...state, { score, dataUri }]);\n\n              webcam.clearCanvas();\n              maskIterator.next();\n            });\n        }\n      });\n    }\n\n    if (maskIterator.maskRef.current) {\n      webcam.ctx.putImageData(maskIterator.maskRef.current, 0, 0);\n    }\n    \n    // return a cleanup function to clear the canvas\n    // use a promise ref since we are capturing asynchronously\n    // if first promise not initialized, clear canvas right away\n    return () => {\n      if (promRef.current) promRef.current.then(controller.webcam.clearCanvas)\n      else controller.webcam.clearCanvas();\n    };\n  }, [webcam, maskIterator]);\n\n  return useMemo(() => ({\n    scores,\n    loading,\n    handleLoop,\n    selectedMasks,\n    handleLoadUserMasks,\n    handleLoadShippedMasks,\n    ready: !!maskIterator.numMasks,\n  }), [\n    scores,\n    loading,\n    handleLoop,\n    maskIterator,\n    selectedMasks,\n    handleLoadUserMasks,\n    handleLoadShippedMasks,\n  ]);\n};\n","import { useRef, useState, useCallback } from \"react\";\nimport { useMemo } from \"react\";\n\n// set masks, iterate masks, retain ref to current mask\nexport const useIterateMask = () => {\n  const [masks, setMasks] = useState([]);\n\n  const maskRef = useRef(null);\n  const maskIdxRef = useRef(0);\n\n  const reset = useCallback(() => {\n    maskIdxRef.current = 0;\n    maskRef.current = null;\n  }, []);\n\n  const next = useCallback(() => {\n    const currentPoly = masks[maskIdxRef.current];\n\n    if (!currentPoly) {\n      maskRef.current = null;\n      maskIdxRef.current = 0;\n\n      return null;\n    }\n\n    maskRef.current = currentPoly;\n    maskIdxRef.current++;\n    \n    return currentPoly;\n  }, [masks]);\n\n  return useMemo(() => ({\n    next,\n    reset,\n    maskRef,\n    setMasks,\n    numMasks: masks.length,\n  }), [\n    next,\n    reset,\n    masks,\n  ]);\n};\n","import JSZip from \"jszip\";\nimport imageDataUri from 'image-data-uri';\nimport { useRef, useCallback, useState } from \"react\";\n\nimport {\n  saveAs,\n  getSegmentationeOverlayAndBinaryImageData\n} from \"../../lib/util\";\nimport { useMemo } from \"react\";\n\nexport const useCaptureMasks = () => {\n  const promRef = useRef();\n  const [masks, setMasks] = useState([]);\n\n  const removeMask = useCallback(({ currentTarget: { name: idx } }) => {\n    // the plus coerces the idx to a number\n    setMasks(state => state.filter((_, index) => index !== +idx));\n  }, []);\n\n  const removeAllMasks = useCallback(() => {\n    setMasks([]);\n  }, []);\n\n  const downloadMasks = useCallback(() => {\n    const zip = new JSZip();\n    const img = zip.folder(\"masks\");\n    masks.forEach(({overlay:mask}, idx) => {\n      img.file(`mask-${idx}.png`, imageDataUri.decode(mask).dataBase64, {base64: true});\n    });\n\n    zip.generateAsync({type:'blob'})\n      .then(zipFile => saveAs(zipFile, 'masks.zip'));\n  }, [masks]);\n\n  const handleLoop = useCallback(async (controller) => {\n    if (controller.time.first) {\n      controller.useTimer({\n        printSeconds: true,\n        announceSeconds: true,\n        lapDuration: 3000,\n        newLapDelay: 1000,\n        // run a single prediction before starting the lap to ensure things roll smoothly\n        onBeforeStartLap: async ({ predict, webcam, time, stop }) => {\n          return predict();\n        },\n        onLap: ({ predict, webcam, time, stop }) => {\n          promRef.current = predict(webcam.videoRef.current)\n            .then(async segmentation => {\n              const {overlayImageData, binaryImageData} = getSegmentationeOverlayAndBinaryImageData(segmentation, webcam.flipX);\n              const overlayDataUri = webcam.imageDataToDataUri(overlayImageData);\n              const binaryDataUri = webcam.imageDataToDataUri(binaryImageData);\n\n              webcam.clearCanvas();\n              webcam.ctx.putImageData(overlayImageData, 0, 0);\n              setMasks(state => [...state, {overlay: overlayDataUri, binary: binaryDataUri}]);\n            });\n        }\n      });\n    }\n    \n    // return a cleanup function to clear the canvas\n    // use a promise ref since we are capturing asynchronously\n    // if first promise not initialized, clear canvas right away\n    return () => {\n      if (promRef.current) promRef.current.then(controller.webcam.clearCanvas)\n      else controller.webcam.clearCanvas();\n    };\n  }, []);\n\n  return useMemo(() => ({\n    masks,\n    handleLoop,\n    removeMask,\n    downloadMasks,\n    removeAllMasks,\n  }), [\n    masks,\n    handleLoop,\n    removeMask,\n    downloadMasks,\n    removeAllMasks,\n  ]);\n};\n","import PropTypes from 'prop-types';\nimport { makeStyles } from '@material-ui/core';\nimport React, { useState, useCallback } from 'react';\n\nimport Button from '@material-ui/core/Button';\n\nimport Webcam from './Webcam';\nimport FileUpload from './FileUpload';\nimport GameSelect from './GameSelect';\nimport WebcamSelect from './WebcamSelect';\nimport ScoreResults from './ScoreResults';\nimport CapturedMasks from './CapturedMasks';\n\nimport { useLoop } from '../hooks/loop';\nimport { useSimpleGame } from '../hooks/loopHandlers/simpleGame';\nimport { useCaptureMasks } from '../hooks/loopHandlers/captureMasks';\nimport { useSingleCapture } from '../hooks/singleCapture';\n\nconst useStyles = makeStyles(theme => ({\n  root: {\n    maxWidth: 1280,\n    margin: '0 auto',\n    padding: theme.spacing(1),\n  },\n  options: {\n    display: 'flex',\n    alignItems: 'center',\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    marginBottom: theme.spacing(1),\n  },\n}));\n\nconst clickStates = {\n  capture: 'capture',\n  simpleGame: 'simpleGame',\n};\n\nconst Main = (props) => {\n  const classes = useStyles();\n  \n  const loop = useLoop();\n  const simpleGame = useSimpleGame();\n  const captureMasks = useCaptureMasks();\n  const handleSingleCapture = useSingleCapture();\n  const [lastClick, setLastClick] = useState(null);\n  \n  const handleClickGame = useCallback(async () => {\n    if (loop.looping) {\n      loop.stop();\n      setLastClick(null);\n    } else {\n      setLastClick(clickStates.simpleGame);\n      loop.start(simpleGame.handleLoop);\n    }\n  }, [loop, simpleGame]);\n\n  const handleClickCapture = useCallback(() => {\n    if (loop.looping) {\n      loop.stop();\n      setLastClick(null);\n    } else {\n      setLastClick(clickStates.capture);\n      loop.start(captureMasks.handleLoop);\n    }\n  }, [loop, captureMasks]);\n\n  return (\n    <div className={classes.root}>\n      <div className={classes.options}>\n        <Button\n          variant='outlined'\n          onClick={handleSingleCapture}\n          disabled={!loop.ready || loop.looping}\n        >\n          Capture\n        </Button>\n        <Button\n          variant='outlined'\n          onClick={handleClickCapture}\n          disabled={!loop.ready || (loop.looping && lastClick !== clickStates.capture)}\n        >\n          {(loop.looping && lastClick === clickStates.capture) ? 'Stop' : 'Capture Masks'}\n        </Button>\n        <GameSelect onChange={simpleGame.handleLoadShippedMasks} disabled={!loop.ready || loop.looping} value={simpleGame.selectedMasks} />\n        <FileUpload\n          variant='outlined'\n          onChange={simpleGame.handleLoadUserMasks}\n          disabled={!loop.ready || loop.looping || simpleGame.loading}\n        >\n          {simpleGame.loading ? 'Loading...' : 'Load Masks'}\n        </FileUpload>\n        <Button\n          color=\"primary\"\n          variant='outlined'\n          onClick={handleClickGame}\n          disabled={!(loop.ready && simpleGame.ready) || (loop.looping && lastClick !== clickStates.simpleGame)}\n        >\n          { (loop.looping && lastClick === clickStates.simpleGame) ? 'Stop' : 'Play' }\n        </Button>\n        <WebcamSelect />\n      </div>\n      <Webcam />\n      <CapturedMasks captureMasks={captureMasks} />\n      <ScoreResults results={simpleGame.scores} />\n    </div>\n  );\n};\n\nMain.propTypes = {\n  cvReady: PropTypes.bool.isRequired,\n};\n\nexport default Main;\n","import { useCallback } from \"react\";\n\nimport { useWebcam } from \"../context/webcam\";\nimport { useBodyPix } from \"../context/bodyPix\";\nimport { getSegmentationeOverlayAndBinaryImageData } from \"../lib/util\";\n\nexport const useSingleCapture = () => {\n  const webcam = useWebcam();\n  const predict = useBodyPix();\n\n  const handleClick = useCallback(async () => {\n    const segmentation = await predict(webcam.videoRef.current)\n    const { overlayImageData } = getSegmentationeOverlayAndBinaryImageData(segmentation, webcam.flipX);\n\n    webcam.clearCanvas();\n    webcam.ctx.putImageData(overlayImageData, 0, 0);\n  }, [predict, webcam]);\n\n  return handleClick;\n};\n","import { hot } from 'react-hot-loader';\nimport { CssBaseline } from '@material-ui/core';\nimport React, { useEffect, useState } from 'react';\nimport { createMuiTheme, MuiThemeProvider } from '@material-ui/core/styles';\n\nimport Main from '../components/Main';\nimport WebcamProvider from '../context/webcam';\nimport BodyPixProvider from '../context/bodyPix';\n\nconst theme = createMuiTheme({\n  background: 'linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)',\n});\n\nfunction App() {\n  const [cvReady, setCvReady] = useState(false);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (window.cvReady) {\n        setCvReady(true);\n        clearInterval(interval);\n        console.log('opencv ready');\n      }\n    }, 200);\n\n    return () => {\n      clearInterval(interval);\n    }\n  }, []);\n\n  return (\n    <MuiThemeProvider theme={theme}>\n      <WebcamProvider>\n        <BodyPixProvider>\n          <>\n            <CssBaseline />\n            <Main cvReady={cvReady} />\n          </>\n        </BodyPixProvider>\n      </WebcamProvider>\n    </MuiThemeProvider>\n  );\n}\n\nexport default process.env.NODE_ENV === 'production' ? App : hot(module)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as serviceWorker from './serviceWorker';\n\nimport './reset.css';\nimport App from './App/App';\n\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}